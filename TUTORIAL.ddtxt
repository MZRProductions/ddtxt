<!DOCTYPE DDTXT>




// Digital Dialogue Text Reader (and Parser)
// Copyright (C) 2023 Michael Rumpff (MZRProductions)

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
// See the GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.




// This document looks chopped up and messy in raw form because there is so much specific formatting. For a more realistic DDTXT, please see example.ddtxt or another sample DDTXT included with the DDTXT Reader.



<global>

name = DDTXT Writing Manual and Syntax Guide (for version 1.0)
webtitle = DDTXT Manual
author = MZRProductions (Michael Rumpff)
provideTableOfContents = true

<style>

// You can use any color the same way that you would in CSS. Here, we are using the common color "white" as the main text color.
color = white
// You can also use the rgb() CSS function.
// This is an RGB value: "rgb(RED, GREEN, BLUE)"
headingColor = rgb(50, 200, 255)
// You can also use the CSS keyword "inherit" to copy the value provided for the "color" slot (the main text color).
// Most of the time, if you do not specify a value, the default will be the main text color.
titleColor = inherit
backgroundColor = rgb(20, 20, 20)

// Setting up the document's divisions:
// (You can use a horizontal border here by using the keyword "(hr)")
divide = ---~~~---
// This is in pixels, and will not grow or shrink according to screen size.
divideSize = 35
// The standard CSS colors defines both "gray" (American?) and "grey" as the same colors:
divideColor = grey

</style>

// Document summary:
<text>

This guide should cover everything needed to start writing a DDTXT document from scratch and clarify the more technical subjects that could help in specific scenarios.

</text>

</global>

// CHARACTER USED TO MAKE HIGHLIGHTED NOTES

<character>

code = note
name = NOTE

<style>

// Main text color:
color = red
// Background color behind character quotes:
backgroundColor = white
// A different color to make the spoken words BUT NOT the character's name.
// (This defaults to the main text color above.)
paragraphColor = rgb(120, 0, 8)
// Since there is a background to this dialogue, we should add some padding to make the edges less jarring.
dialoguePadding = 1%

// Text nodes inside of characters feed into their biography.
<text>

This character is used as a way to highlight important distinctions. By making the background color different and using a different text size, the words here are immediately noticeable.

</text>

// Since this isn't a real character, there is no need to specify pronouns.
// If you attempted to use this character's pronouns (">note", for example),
// you would get the default generic pronouns:
// They, them, their, themselves, they are, they're, ect...

</style>

</character>

// CHARACTER USED FOR HEADINGS

<character>

// I'm too lazy to use "MZRProductions" every time.
code = me
name = MZRProductions

<pronouns>

subject = he
object = him
possessive = his
reflexive = himself
present = he is
// We have to specify both.
presentCompacted = he's

</pronouns>

<text>

I hope you enjoy the DDTXT format and find it useful! This manual should cover enough to at least get you started. Thanks for reading my bio!

</text>

</character>

<character>

code = prop
// (Short for property)
name = New Document Property

<style>

color = rgb(10, 50, 20)
backgroundColor = lightgreen
dialoguePadding = 1%

</style>

<text>

This styling is used to clearly show new properties as they are introduced.

</text>

</character>

<character>

code = text
// I'm including the explanation phrase in the name so that we don't have to re-type it.
name = Raw Document Example (Your file should look something like this)

<style>

color = white
backgroundColor = darkblue
dialoguePadding = 1%

</style>

<text>

This styling is used to display functional examples and/or snippets of DDTXTs.

</text>

</character>

// EXAMPLE STORY CHARACTERS
// (I don't care about the names here.)

<character>

code = example1
name = Elizabeth

<pronouns>

subject = she
possessive = her
// Yes, "her" is used for both "to her" and "her random object"
object = her
reflexive = herself
// Here, the instance pronoun is being used to tell the role of the character in the story, which is the main use of it.
instance = catapult
present = she is
presentCompacted = she's

</pronouns>

<text>

@example1 is the character throwing @example2 to @example3.

</text>

</character>

<character>

code = example2
name = Timmy

<pronouns>

subject = they
possessive = their
object = them
// I'll be honest, I don't know much about the word "themself," or if that word would be more fitting. I always opt for "themselves."
reflexive = themselves
// Here, the instance pronoun is being used to tell the role of the character in the story, which is the main use of it.
instance = rubber ball
present = they are
presentCompacted = they're

</pronouns>

<text>

@example2 is a ~example2 that gets thrown by @example1. Don't ask me why. I suppose you can change the character information to make something that makes more sense.

</text>

</character>

<character>

code = example3
name = Bob

<pronouns>

subject = he
possessive = his
object = him
// I'll be honest, I don't know much about the word "themself," or if that word would be more fitting. I always opt for "themselves."
reflexive = himself
// Here, the instance pronoun is being used to tell the role of the character in the story, which is the main use of it.
instance = giant bowl
present = he is
presentCompacted = he's

</pronouns>

<text>

@example3 is a ~example3 used for catching @example2. Why? I don't know. Yes, it's all very weird, but this was the best way I could think of to demonstrate pronouns.

</text>

</character>

// IN-TEXT DDTXT COMMANDS:

<character>

code = command
name = In-Text DDTXT Command

<style>

color = black
backgroundColor = orange
dialoguePadding = 1%

</style>

</character>

<character>

code = ref
name = Reference Symbol

<style>

color = white
backgroundColor = magenta
dialoguePadding = 1%

</style>

</character>

// ONE TIME CHARACTERS FOR STYLING DEMONSTRATIONS:

<character>

code = hardToRead1
name = Pro tip

<style>

color = rgb(40, 40, 40)

</style>

<text>

Could you actually read the text without highlighting it in your browser?

</text>

</character>

<character>

code = hardToRead2
name = Red and Green

<style>

color = rgb(45, 160, 0)
backgroundColor = brown
dialoguePadding = 1%

</style>

<text>

This character style is meant to be not great but not horrible.

</text>

</character>

<character>

code = hardToRead3
name = COLOR EXPLOSION

<style>

color = magenta
backgroundColor = rgb(0, 255, 0)
paragraphColor = blue
dialoguePadding = 1%

</style>

<text>

This character style is meant to be ugly and hard to look at.

</text>

</character>

// We are going to have to use "(break)"s a lot in-text. This isn't needed for most DDTXTs.
// I'm only using it to make information more readable. 

<chapter>

name = Introduction
// I'm using the keyword "none" to not display any subtitle.
// You can use this for main names too.
subtitle = none

<text>

[me: Hello! Welcome to the DDTXT format!]

The Digital Dialogue Text format, abbreviated as DDTXT, is a specific markup language that makes writing dialogue-heavy documents (such as scripts or casual stories) simpler by using frequent references that point to characters designed by the author. The DDTXT also excels in flexibility since readers can change the language used to refer to characters and make characters more or less personally relatable. Because DDTXTs are shorthand for very basic webpages, the format should be supported almost everywhere.

// We use the keyword "(break)" to split paragraphs.
// By default, this is equivalent to two HTML "<br>"s, but this can also be changed in the <global> node.
(break)

The DDTXT document is split into three main categories. There are sections where you write 
// We can write a comment here and this sentence will remain whole.
// The text inside of <text> nodes follows HTML standards, which means spacing is mostly ignored.
// However, since the character before the split is not punctuation, there is no way of knowing that
// there needs to be an extra space, so you will have to add a dollar sign to indicate that you meant the extra space.
// Normally, spacing is completely ignored (in a similar manner to HTML text).
$ the actual document, sections where set the document's properties, and sections where you organize the previous two kinds of information. It should be noted that the DDTXT in raw form reads similarly to fake XML, although the structuring of nodes is much more simplistic and limited. If you do not know anything about the XML, HTML, or CSS languages, you should be able to pick up the DDTXT format without learning about them.

(break)

This guide will begin on general instructions for creating a DDTXT document and then end with specific reference materials for advanced users. You can visit the advanced section by clicking the link here:

[href: ##chapter-6]

// You can use a "(divide)" at any time to include a larger break with a fancy divider

(divide)

[me: I hope that you enjoy reading and writing DDTXTs.]

</text>

</chapter>

<chapter>

name = Starting Your Own DDTXT
subtitle = Basic rules:

<text>

[note: You should open a text editor (like Notepad) and create a new file with the file extension ".ddtxt" (for example, "test.ddtxt") before continuing so that you can easily follow along.]

The first line of every raw DDTXT file (the text file that you see when you open the file in a text editor) must be the exact following, without the quotation marks:
// You can use dollar signs to tell the DDTXT parser to not translate the following word.
// (You must use a dollar sign after every space.)
$"<!DOCTYPE $DDTXT>". This is required as a precaution so that if there are other file formats that use the .ddtxt filename extension the DDTXT Reader doesn't read other file types.

(break)

Before we continue, I must explain rules that apply across the entire DDTXT document.
(break)
// Em dashes have a bit more presence than a single hyphen.
(em dash) Unless otherwise noted, individual actions must be on their own line.
(break)
(em dash) Author comments can be written in the raw DDTXT file by starting a line with two forward slashes ("//"). These never affect the finished DDTXT in any way.
(break)
(em dash) Capitalization often matters and failure to write phrases or keywords exactly as given may result in document properties not being set correctly.

</text>

</chapter>

<chapter>

name = Setting Up Your DDTXT's Basic Elements
subtitle = Setting global document properties

<text>

Document properties are what tell your browser specifically how to display your writing as a DDTXT. These properties are organized into chunks called "nodes," which is how I will refer to these from now on. Nodes are started by commands on a single line, which either open or close these chunks. In addition, there can be chunks within chunks (subnodes), but these will be clearly documented for ease of understanding.

(break)

Let's start by setting the document name. Making sure that the file starts with the exact line $"<!DOCTYPE $DDTXT>", create the global properties node by writing $"<global>" on a line below. Now, on an even lower line, write $"</global>" to close the node. Any line between these two endpoints will be interpreted as information relating to the entire document. Think of the properties within the global node of your document as applying "globally," that is everywhere within your document.

(break)

Now, you can set the document's name. To do this, create a new line inside the global properties node and write "name  #= My First DDTXT".

[prop: name]

If you save the file and open up the document in the DDTXT Reader, you should see a blank DDTXT titled "My First DDTXT". Every line setting a property of the document will follow the format 
// We must comment out the reference character "=" here by putting a hashtag before it.
"  #= value".

(break)

Now, you should credit yourself as the author so that people know that you wrote it. You can do this by writing a new line that starts with "author  #= " followed by your name.

[prop: author]

At this point, you should save you file and open it with the DDTXT Reader. (If it's easier for you, you should be able to open the DDTXT Reader twice and keep this Manual open.) The document should be named and should note you as the author. If something went wrong, don't worry. Simply look over this example and study it:

// You can use "(break)"s in dialogue. I would only recommend doing this if you have changed the background color of the character's dialogue and need to do so in order to have some margins. (This should be avoided in main stories without good reason.)

[text:

(break)

$<!DOCTYPE $DDTXT>

(break)
<global>
(break)

name $= My First DDTXT
(break)
author $= MZRProductions (Michael Rumpff)

(break)

$</global> ]

</text>

</chapter>

<chapter>

name = Setting Up a Character!
subtitle = Bringing life to your stories

<text>

Most stories will include characters of interest and feature interactions between them. For this, you must register each character through a character node. Much like the global node previously discussed, each character node begins with the line $"<character>" and ends with the line $"</character>".
// Once again, we are using the dollar sign to have the parser skip over the words containing character references.

[note: Unlike the document's global node, of which there should only be one, there must be a new character node for each new character.]

The first thing to include in a character node is the designated word that you will use to refer to this character. This is done by setting the "code" property.

[prop: code]

Of course, as with setting any individual property, this is done by specifying the property you want to set followed by an equal sign and your desired value. This single word, or a phrase with no spaces, will be used in conjunction with references, which we will discuss later. Read about them here: [href: ##chapter-5]. It is highly recommended that you keep your "code" keywords short since you will be typing them repeatedly!

(break)

The "code" property above only has its special meaning when used with a reference. This means that you can use a common word that you could repeat within the story without worrying about conflict. In addition, the "code" keyword that you use to refer to the character in-text can be different from the name that the reader sees when you reference the character. To set the name of the character, use the "name" property.

[prop: name]

The character's name can be multiple words, if you choose, unlike the code keyword.

[text:

(break)

// We have to use hashtags and dollar signs to help the parser out here.

$<character>

(break)

code  #= example
(break)
// You can see here that the code is one word, but the name is two words.
name  #= Example Character
(break)
$</character> ]

The next thing to think about are the character's pronouns, which will be pulled from as you write your document.

</text>

</chapter>

<chapter>

name = Character Pronouns
subtitle = The building blocks of character interactions

<text>

In order to specify your character's pronouns, you must first create a pronouns subnode inside of a character node. Inside of the character node, make a new line with "<pronouns>" and another line below it with "</pronouns>". Hopefully creating nodes and subnodes is making more sense now. Each property below is an individual pronoun. You can choose to define any, all, or none of them. The values of all of these properties should be a word or phrase. (If you do not define a pronoun, the gender neutral equivalent will be used.)

(break)

// This will be done properly with DDTXT characters so that you can see how references function.

Let's invent a little story with three characters. The story is silly, but it illustrates many common pronouns interacting with characters.

[note:

(break)

The first character is @example1, a ~example1.

(break)

The second character is a ~example2 named @example2.

(break)

The third character, @example3, is a ~example3 for catching a ~example2.]

In case the specifics of writing with personal pronouns confuse you (understandably so), I will detail what each pronoun does. To learn more about using these pronouns with references, click here: [href: ##chapter-5].

[prop: subject]

This is the word that indicated the character performing the action. In this story, @example1 is throwing @example2, so @example1 is the subject. This means that we should use +example1 subject word here, in this case "<example1."

[prop: possessive]

This is the word that describes someones possessive relation to something else. For example, since @example1 is a ~example1, we can assume that one of =example1 talents is throwing spherical objects. The talent of throwing belongs to >example1.

[prop: object]

This is the word that refers to the character that the action is happening to. Think "to them", "to her", or "to him" here. In the story above, @example2 is being thrown to @example3. @example3 is the direct receiver of this action, which means that
// Here we are using reference shorthand. Since the previous reference involved the same character, we don't have to re-type the character's code keyword. The DDTXT Parser will assume that this is a reference to example3.
< is the direct object.

(break)

@example2 is involved in this action too, but as an indirect object. @example2 is being used to perform the action in the first place. In the English language, both direct objects and indirect objects have the same pronoun form, so the important thing is that they are both objects.

[prop: instance]

This is more vague. This can be anything that you want, really. I would recommend making this the character's role in the story or something that the character would call themselves. For example, because @example2 is a ~example2, <example2 is easier to throw than @example3, a ~example3.

(break)

Hopefully you can see the flexibility of this property. The main thing is that writers make sure to not rely on this too much, but to use this pronoun as a tool to make new characters familiar enough that you don't need this anymore. It's up to you to figure this one out.

[prop: reflexive]

This word describes actions that a character is performing on or toward themselves. For example, when you are performing actions to take care of yourself and fulfill your needs, you are performing reflexive actions. Actions that directly reflect back to the subject are reflexive. Most often, these words will contain "self" or "selves".

[prop: present]

This isn't technically a pronoun, but it is used with the character's actual pronouns. This is the linking verb (to be) that would be used in passive voice and present progressive tenses. In simpler terms, this would be a "he is" or "they are". This can be used in combination with other verbs. For example, due to the fact that @example2, the ~example2, is flying through the air, {example2 preparing to land and bounce into the air again.

[note: You do not need to use this if the verb directly follows a character name, as this situation always calls for the verb "is."]

// "@example1 is" is fine as is, but "<example1 is" should be converted to "{example1".

Any time you have a subject followed by "is" or "are," you'll most likely want to convert this phrase to the character's present pronoun.

[prop: presentCompacted]

This is the contracted (abbreviated) form of the present verb form property above. This is a seperate property, although it can be created from the phrase above by replacing the first letter of the second word with an apostrophe (') and combining both new words into one word. For example, "they are" becomes "they're"; "she is" becomes "she's".

(divide)

Here is a list of these three characters from the story with all of their pronouns.

// These are going to be long tables of pronouns.

[note: @example1]

Subject | <example1
(break) Possessive | =example1
(break) Object | (to) >example1
(break) Instance | (is a) ~example1
(break) Reflexive | *example1
(break) Present Helping Verb | {example1
(break) Present Helping Verb Contraction | }example1

[note: @example2]

Subject | <example2
(break) Possessive | =example2
(break) Object | (to) >example2
(break) Instance | (is a) ~example2
(break) Reflexive | *example2
(break) Present Helping Verb | {example2
(break) Present Helping Verb Contraction | }example2

[note: @example3]

Subject | <example3
(break) Possessive | =example3
(break) Object | (to) >example3
(break) Instance | (is a) ~example3
(break) Reflexive | *example3
(break) Present Helping Verb | {example3
(break) Present Helping Verb Contraction | }example3

(divide)

Here is an example of a character with name, code, and pronouns defined. (The pronouns listed here are the default pronouns that you would get for each if you didn't specify them anyway.)

[text:

(break)

// We have to use hashtags and dollar signs to help the parser out here.

$<character>

(break)

code #= example
(break)
// (If you want to include comments in these weird example snippets, you can put a hashtag before the comment slashes.) Notice how since this comment does not have a hashtag it's a real comment. Sorry if this confused you.
#// You can see here that the code is one word, but the name is two words.
(break)
name #= Example Character
(break)
$<pronouns>
(break)
subject #= they
(break)
possessive #= their
(break)
object #= them
(break)
reflexive #= themselves
(break)
instance #= person
(break)
present #= they are
(break)
presentCompacted #= they're
(break)
$</pronouns>
(break)
$</character> ]

</text>

</chapter>

<chapter>

name = The DDTXT Language
subtitle = Preparing to write with references

<text>

The DDTXT format can take some adjustments when thinking about how to write, but it will soon save you time as you can quickly expand upon your document. The DDTXT introduces character references that transform "hard baked" text into dynamic, changeable text. Text that is hard baked is rigid. It is written and stays the same. Dynamic text adapts to character pronouns and works to promote character relatablility while keeping the true story elements intact. This allows readers to digest your writing more easily.

(break)

It will be difficult at first as you learn the DDTXT language, but you should avoid hard baking your text. Hard baking makes text less accessible to readers and ignores most of the intended function of the DDTXT format.

(divide)

All main document text is written within text subnodes. However, before you can write, you need to create a chapter node. This is a main node, not a subnode, and it should come after your character nodes and your global node. There are two main properties of chapter nodes other than the text subnode. Both of these properties takes words as input.

[prop: name]

This is the chapter title (or name). This appears at the top of the chapter, before any main chapter text.

[prop: subtitle]

This is the chapter's subtitle, which is shown beneath the chapter's title.

[note: Both the chapter name and subtitle can be turned off by using the keyword "none" as the property value.]

[note: The chapter title and subtitle will be colored according to the document's headingColor as defined in the style subnode of the document's global node.]

For more information, please see the global style subnode. [href: ##chapter-8].

(divide)

Now that you have an empty chapter, you can start writing by creating a text subnode. This will be a subnode of your chapter node.

(break)

Any text written within this subnode, excluding comments, is interpreted according to DDTXT format. It should be noted that spacing is only relevant between written text. This means that you can and should organize your raw DDTXT file for readability by other authors and/or editors.

// Seriously. This file is already cluttered enough as it is. If you don't try at all, your file will be even more cluttered!

(break)

Empty space to the left or right will be omitted by default. You can write an entire paragraph on one line or make each sentence a new line. If you are having problems with spacing, you may need to insert spaces. For more information, see the DDTXT Commands Chapter. [href: ##chapter-9].

</text>

</chapter>

<chapter>

name = Character Dialogue
subtitle = Finally! (The whole point of the DDTXT)

<text>

The DDTXT should be dialogue heavy, as that is the entire point of using the DDTXT instead of standard HTML webpages or the straight to the point .txt file.

[me: Hello! Look, it's dialogue!]

To insert dialogue into your story, begin by writing a pair of square brackets. Anything inside of these brackets will be written as dialogue in your document. However, before you get writing, you need to specify who is talking! Each dialogue entry is actually split into two sections. The left side specifies the character and the right side holds the spoken words.

(break)

In order to specify the character speaking, you use the character's code. (From now on, I'll just say "character code.") This is the shorter, abbreviated version of the character's name that you setup before. [href: ##chapter-4]

(break)

Now that you have the character code written inside the brackets, you need to split the dialogue into two parts with a colon (:). This allows your character code to be distinguished from the character's words. This colon can be spaced however you want as long as it is between the character code and the spoken words.

(break)

Now you just have to write the words that you have been wanting to write this whole time while you have been reading this chapter. The dialogue should now appear as a larger, bold line of text split from the rest of your text. If something went wrong, study this example.

[text:
(break)
$<text>
(break)
Look! Here is some big text.
(break)
(left bracket)code: Hello World!(right bracket)
(break)
$</text>
]

</text>

</chapter>

<chapter>

name = Character References
subtitle = Using character information in your written work

<text>

You may have already discovered how difficult it is to write a story without using character names or pronouns. This chapter discusses the second most important part of the DDTXT, character references. These allow you to insert character information and pronouns directly into your document. These "references" all point back to the character node that you created earlier.

(break)

The DDTXT language requires you to make your writing abstract. Instead of writing character information directly, you place references, which pull from the character node (and pronouns subnode) that you made earlier. These references can be used anywhere that the DDTXT language is used. They will require you to think about language differently, but you should get the hang of it quickly. Let's take a look at this example drawing on the "story" from Chapter 5 [href: ##chapter-5].

[note: "To answer your question, HER name is ELIZABETH. SHE IS a CATAPULT."]

All of the CAPITALIZED words are character information that needs to be converted to character references for a character with the code "example1":

// If you are reading this in the editor (you are) than ignore the dollar signs. They are just so that reader can read it correctly.
[note: To answer your question, $=example1 name is $@example1. ${example1 a $~example1.]

(When this text gets converted to the finished version by the parser, it looks like this).

[note: To answer your question, =example1 name is @example1. {example1 a ~example1.]

These words that start with special symbols are character references and the symbols are "reference symbols." You are probably confused by the abstract language, but I will go over each type of reference symbol and give you plenty of usage examples.

(divide)

[ref: #@]

</text>

</chapter>

<chapter>

name = Using Reference Symbols Literally
subtitle = ## and #$

<text>

This concept is applied to more complicated situations, although you shouldn't have to worry about this too much. Sometimes you will want to use symbols reserved for character references as the actual symbol and not the reference function. This process of using these symbols literally will be referred to as "literalizing" (this is not a real word).

(break)

(For programmers, this is similar to programming with escape characters within strings or commenting out program comments.)

(break)

Consider the following example of formatted text.

[note: "5 #+ 3 #= 8"]

The above text will be interpreted as two character references. Since there is no character code given, it will be interpreted as codeless shorthand, which defaults to the last used character. Two pronouns will be plugged in here and this addition problem will be turned into something unintelligible like this.

[note: 5 +example2 3 =example1 8]

To fix this, we will use the hashtag (##) symbol. This "literalizes" (again, not a real word) the symbols, causing them to be treated as normal text and not character references. This means that the problem can now be read. These hashtags will be invisible in your final document.

(break)

To use a hashtag, simply place the hashtag directly before the reference symbol that you want to literalize. 

// This is really fun to write in raw form:
[text: 5 ###+ 3 ###= 8]
[note: 5 #+ 3 #= 8]

To use readable hashtags in your document, simply use two hashtags back-to-back.

[text: I love hashtags! ####]

[note: I love hashtags! ##]

(divide)

Now consider this example. Let's say that you want to use a lot of symbols at once.

[note: $"~<=*+~+*=>~"]

In order to see all of these properly in your DDTXT, you would have to use a lot of hashtags.

// Lots of fun had here:
[text: ###~###<###=###*###+###~###+###*###=###>###~]

Instead of breaking your number 3 / hashtag key,
// (seriously)
$ use the dollar sign symbol. (I am not sure if this will be accessible internationally.) The dollar sign tells the parser to skip past the following word entirely.

[note: Commands can still be triggered within these words! This is not an intentional feature, although it does not get in the way, so it will likely stay that way.]

Consider this horrible example again.

// I just copied/pasted this, not typing that again.
[note: "###~###<###=###*###+###~###+###*###=###>###~"]

Using a dollar sign instead, this becomes much simpler.

// You can also use the dollar sign where you would use a hashtag, although its longer stretch is wasted.
// In addition, this will literalize characters further on in the same word, which might not be what you want.
[text: $$~<=*+~+*=>~]

To literalize a dollar sign, you can use a hashtag directly before the dollar sign just like you would any other symbol.

[text: ###$]

[note: #$]

(divide)

You might have noticed that your sentences lack spaces if you split them apart between regular words and not punctuation. Consider this example.

[text:
(break)
This sentence
(break)
gets glued together!
]
This text in a text subnode would get translated to the following.

[note: This sentencegets glued together.]

You could just write the sentence on a single line, but the whole point of the DDTXT is flexibility. This becomes especially important if you are trying to write author comments in the middle of sentences for
// (Distracting comment)
$ clarification and editing.

(break)

The DDTXT parser (and HTML parser) remove extra space, which means that just adding an extra space at the beginning of the line will not do anything.

(break)

To correctly add the space back in between "sentence" and "gets," you can add a dollar sign or a hashtag followed by the extra space(s) you need.

[text: 
(break)
This sentence
(break)
#$ gets glued together.]

[note: This sentence gets glued together.]

This works since the hashtag and dollar sign are both designed to be working invisibly behind the scenes. Because they are both removed unless literalized, they tell the DDTXT parser to include the extra space and then are removed from the finished document.

</text>

</chapter>

<chapter>

name = DDTXT In-Text Keywords
subtitle = Special commands to use to format your DDTXT

<text>

There are some things that require special keywords, which perform specific actions. These commands will help tremendously. All of these commands must be written inside parentheses, however there is nothing special about these parentheses unless one of these keywords is used. (For example, this does not trigger any action.)

// Look, here is one of these commands:

(divide)

[command: (left parenthesis)break(right parenthesis)]

This will split your text apart. By default, this will leave space in between your text, but you can change this by setting the "break" property within the global style subnode. (You can also make this longer.)

[command: (left parenthesis)divide(right parenthesis)]

This will split your text and place a division decoration in your document. A division was used to split this section off from the introduction to this chapter.

[command: (left parenthesis)horizon(right parenthesis)]

This will insert a line across your document (a horizontal rule). This is equivalent to the HTML $"<hr>". This is what it looks like:

(horizon)

[command: (left parenthesis)em dash(right parenthesis)]

This command places an em dash ((em dash)). This provides convenience since it can be difficult to type these.

(divide)

All of the following commands replace a character reference symbol or another symbol of DDTXT functionality that you can't use easily as a literal symbol. This makes it easy to write these symbols without using them functionally.

[command: (left parenthesis)at symbol(right parenthesis) | #@]

[command: (left parenthesis)equal symbol(right parenthesis) | #=]

[command: (left parenthesis)less than symbol(right parenthesis) | #<]

[command: (left parenthesis)greater than symbol(right parenthesis) | #>]

[command: (left parenthesis)asterisk symbol(right parenthesis) | #*]

[command: (left parenthesis)tilde symbol(right parenthesis) | #~]

[command: (left parenthesis)left curly brace(right parenthesis) | #{]

[command: (left parenthesis)right curly brace(right parenthesis) | #}]

[command: (left parenthesis)left bracket(right parenthesis) | (left bracket)]
// For the next line, we have to use the (right bracket) command to write it without ending the dialogue entry.
[command: (left parenthesis)right bracket(right parenthesis) | (right bracket)]

The following two are mostly useful for this section here, as they allow me to write these commands down without using them.

[note: You can write parentheses normally without triggering a command as long as they aren't around any of these command keywords.]

[command: (left parenthesis)left parenthesis(right parenthesis) | (]

[command: (left parenthesis)right parenthesis(right parenthesis) | )]

The following two can be used to write both of the symbols (## and #$) used to comment out other symbols.

[command: (left parenthesis)hashtag(right parenthesis) | ## (You can also write "####".)]

[command: (left parenthesis)dollar sign(right parenthesis) | #$ (You can also write "###$".)]

</text>

</chapter>

<chapter>

name = Other Uses of the DDTXT Language
subtitle = +example3 name can be used in chapter headings

<text>

The primary use of formatted DDTXT text is in the text subnodes of chapter nodes. However, these character references and in-text DDTXT commands can be used in other parts of your document.

(divide)

Besides chapter nodes, there are two ways to use text subnodes.

(break)

You can put text subnodes in character nodes. Anything you write inside of these text subnodes will contribute to that character's biography, visible in the document's summary box. You can view these biographies at any time by clicking the "Show stats." button in the DDTXT Reader (if the "Summary" button is not already visible) and then clicking "Summary".

[note: The (left parenthesis)horizon(right parenthesis) command and the (left parenthesis)divide(right parenthesis) command currently do not work in biographies, although this might change in the future.]

You can also put text subnodes in the document's global node. This text contributes to the document's main summary, which appears at the top of the summary box. 

(divide)

The DDTXT text formatting tools can also be used in chapter titles, subtitles, and the name of your entire document. This chapter's subtitle has character references in it. The main difference between these inputs and a text subnode is that you can only use the line that the property is on. Line spacing matters here.

[note: Some features like the (left parenthesis)break(right parenthesis) command, the (left parenthesis)divide(right parenthesis) command, and character dialogue will not work as expected due to the nature of HTML headings.
(break)
I do not intend to change this as these features are not necessary for chapter titles, subtitles, and document names.]

Look at this chapter node. This is WRONG. If you do this, you will get errors.

[note: 
(break)
$<chapter>
(break)
name #= The Adventures of #@example,
(break)
where something happens!
(break)
subtitle #= #+example origin story
(break)
$</chapter>
]

The above example must be changed to this. If your view of this document is squished horizontally, I will emphasize that this is all one line, although for you it might look like multiple lines.

[text: 
(break)
$<chapter>
(break)
name #= The Adventures of #@example, where something happens!
(break)
subtitle #= #+example origin story
(break)
$</chapter>
]

The same principle applies to the document name. Here is what that looks like.

[text:
(break)
$<global>
(break)
#// Character's Exciting Day!
(break)
name #= #+example Exciting Day!
(break)
#// The author field is normal text. You can't use formatted text here.
(break)
author #= Carol #& Michelle 
(break)
$</global>
]

</text>

</chapter>

<chapter>

name = Character Styling
subtitle = Applying colors to characters

<text>

Before we discuss how to set your characters' styles, we should discuss good practices for color choices.

[note: READABILITY IS IMPORTANT!]

For example, read the next part about an important feature of styles:

// This text is supposed to be almost invisible on the background. (Dark on dark)
[hardToRead1: Text that is difficult to read is almost useless.]

Did you read that? Accessibility to your readers is of the utmost importance! This next example is fairly readable to non-colorblind people reading from brighter screens, although this could become an issue for readers who struggle to distinguish these colors:

[hardToRead2: Colors of medium readability can be the trickiest to diagnose and adjust. It's important to be able to determine when to increase the contrast of your document.]

You should probably also try to avoid adding too many colors, as this will be annoying to your readers:

[hardToRead3: I bet you can read this now!!]

You can see that all the text in this document has a theme of light on dark or dark on light. This is very intentional. You need to be able to read how to make DDTXTs, right? Styling should never hinder the document; it should only complement it.

(break)

Really, this is all theory, so use your best judgement. Ideally, you should have other people try to read your document or perform some of the following tests.

(break)

- You can try zooming out in your browser (it might be buried in a miscellaneous actions drop down menu). If you can still read text without straining your eyes too much, then you should be safe.
(break)
- Turn your screen's brightness down temporarily. If the text is still fairly visible, then you're probably safe.
(break)
- If you have a way to easily screenshot your screen, take a screenshot of some dialogue in your document. Then, if possible, desaturate the picture with a "Black and White" filter or by turning the saturation down to 0%. If you can still read your text, then you're probably safe.

(divide)

It is time to discuss a new type of subnode. The style subnode tells your browser how to display dialogue spoken by your character. There are currently four different properties. Each of these properties, unless otherwise stated, uses CSS.

(break)

CSS, which stands for Cascading Style Sheets, is a well-established language for storing colors and styles for webpages and is essential to browsers. You can look up further CSS references online, although I'll discuss every part of CSS that apples to DDTXTs here.

(break)

CSS contains a plethora of predefined colors for you to use. These can be used by finding a CSS color word, such as "blue", and using that word as the value for the DDTXT property. The easiest way to see if a color has been predefined in CSS is to try a color word and reload the DDTXT.

(break)

You can find a list of CSS colors here: [href: https://www.w3.org/wiki/CSS/Properties/color/keywords#Basic_Colors]. If this link becomes obsolete, you should be able to find other CSS resources online.

(break)

You can also choose an exact color using the RGB color system, which stands for Red, Green, and Blue. Color pickers allow you to select a color from an interactive color wheel and then read the corresponding RGB numbers. (You should be able to find online color pickers.) To use these numbers, start the value with "rgb(". Then write the numbers as a comma seperated list. Finally, close the parentheses. It should look something like this: "rgb(255, 127, 63)".

(break)

(This paragraph is for people who are already familiar with the RGB system and the idea of hexadecimal numbers.) By the way, a hexadecimal color is an RGB value combined to form six hexadecimal digits back to back. The first two are the red component, from 0 (00) to 255 (FF). The middle two are the green component, and the final two are the blue component. (Alpha / opacity would be represented by an additional two digits if the color is actually an RGBA color.) For example, the color "32, 127, 161" becomes "##207FA1". (Hex colors usually are written with a hashtag at the beginning.)

[note: If you would like to use the default value that the document would apply naturally, use the CSS keyword "inherit". This results in the same default color that you would get by not specifying a color, but it could let others know that you really meant to not specify a color. It's up to you.]

(divide)

Here are the properties that control dialogue display in your document.

[prop: color]

This is the color of the text that your character speaks in dialogue and the color of their name that appears next to their words. If not specified, this will default to the color of the chapter text throughout the rest of the document. For more information on the color of chapter text, go here: [href: ##chapter-8]

[prop: backgroundColor]

You can choose to set a background color for your character's dialogue. I would recommend using colors of subtle difference to the main document, if any background color at all. If you do this, I would also recommend setting the character's dialoguePadding property. (See below.)

[prop: paragraphColor]

You can also choose to set the color of the character's spoken words a different color than the color of the character's name in the dialogue snippet. This should be a shade different from the character's main color, if different at all.

[prop: dialoguePadding]

[note: This property does not use CSS colors!]

This property adds an inner margin to dialogue boxes. This should only be used when the character's backgroundColor property is different from the document's main background color. The value of this property should be a percentage of the screen that you would like to pad the dialogue with. It is highly recommended to use small values like "1%" or "2%" at most.

(divide)

Here is an example of the style subnode of a character node.

[text:
(break)
$<style>
(break)
color #= black
(break)
backgroundColor #= yellow
(break)
dialoguePadding #= 1%
(break)
$</style>
]

</text>

</chapter>

<chapter>

name = Global Document Styling
subtitle = Creating a style for your entire document

<text>

The same ideas behind character styling apply to styling the rest of your document. Visibility and accessibility should be the focus of styling your document since this covers paragraph text, which is smaller than character dialogue. Just like in characters, document styling is done in a style subnode. Create a style subnode within the global node [href: ##chapter-3], which you should have already made.

(break)

The values for color properties here should be CSS colors. [href: ##chapter-7] Values in other forms will be highlighted.

[prop: color]

This is the main color of text throughout the document. Chapter text, headings, and character dialog will default to this color. This document has a color of "white", which means that all text, unless otherwise specified by character styles or heading styles, will be white.

[prop: backgroundColor]

This is the background color of the entire document. This should be a color that is readable behind all of the different colors of your document. This document has a backgroundColor of "black", meaning that the background color is black except for character dialogue that specifies otherwise.

[prop: headingColor]

This is the color of chapter titles and subtitles. This document has a headingColor of "rgb(50, 200, 255)", which means that chapter titles and subtitles have a lighter blue color.

[prop: titleColor]

This is the color of your document's title. In this document, the titleColor is "inherit", which pulls from the color property ("white"). This means that the title of this DDTXT is white.

(divide)

[prop: divide]

[note: This property takes words or a phrase as input.]

This is the text that is used as a division between sections upon being called through the in-text keyword "divide". This can be made up of any text characters, including spaces. The default value is $"~~~", which uses aesthetically pleasing tildes to break apart your DDTXT. This document uses $"---~~~---", which extends these tildes.

[prop: divideColor]

This is the color of the divisions in your DDTXT. This works like all of the other text color properties.

[prop: divideSize]

[note: The value should be a number directly followed by "px", which stands for pixels.]

This is the font size of the divisions in your document. This number is in pixels. The default size of divisions is the same size as paragraph text. This document uses a division size of "35px", which makes divisions a similar size to character dialogue.

(divide)

Here is this document's global style subnode.

[text:
(break)
$<style>
(break)
(break)
#// You can use any color the same way that you would in CSS. Here, we are using the common color "white" as the main text color.
(break)
color #= white
(break)
#// You can also use the rgb() CSS function.
(break)
#// This is an RGB value: "rgb(RED, GREEN, BLUE)"
(break)
headingColor #= rgb(50, 200, 255)
(break)
#// You can also use the CSS keyword "inherit" to copy the value provided for the "color" slot (the main text color).
(break)
#// Most of the time, if you do not specify a value, the default will be the main text color.
(break)
titleColor #= inherit
(break)
backgroundColor #= rgb(20, 20, 20)
(break)
(break)
#// Setting up the document's divisions:
(break)
#// (You can use a horizontal border here by using the keyword $"<hr>")
(break)
divide #= $---~~~---
(break)
#// This is in pixels, and will not grow or shrink according to screen size.
(break)
divideSize #= 35px
(break)
#// The standard CSS colors defines both "gray" (American?) and "grey" as the same colors:
(break)
divideColor #= grey
(break)
(break)
$</style>
]

</text>

</chapter>

<chapter>

name = Advanced Documentation

// ISSUE: Move this temporary text into the chapter before the split.

<text>

(break)
(break)
(break)
(divide)
(break)
(break)
(break)

</text>

</chapter>