<!DOCTYPE html>

<!--

	Digital Dialogue Text Reader (and Parser)
	Copyright (C) 2023 Michael Rumpff (MZRProductions)

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

-->

<!-- You are currently viewing v0.2.1 of the DDTXT language. -->

<!--
TODO: Fix usePluralVerbForm Character attribute usage.
TODO: Fix or remove hardbaked text, as it currently provides more problems than benefits.
TODO: Verfiy correct XML organization of <html> header node.
TODO: Verfiy that CSS inheritance (as in "color: inherit;" etc...) is applying DDTXT style changes to the webpage correctly.
-->

<!-- Future Ideas: -->

<!--

- Introduce (silence) DDTXT command
- Introduce a way of setting custom commands. The syntax would be something along the lines of (`CUSTOMNAME) with a grave accent (`). This would be a simple search and replace system, so there would not be much overhead. The most complicated part of this would be using it. I haven't needed anything like this so far, although it might not be a bad idea in the future.
- The same as above but with character pronouns. The syntax would be something along the lines of `custom`charactercode. These custom replacements would have to be worth the added complexity.
- Verb plurality ternary, as "included" (but not functionally) in the original versions of the DDTXT language. Right now, this also isn't very important.
- Optional background images instead of solid colors.
- Different styles for individual chapters.

-->

<!-- HTML -->

<html lang="en-US">

<!-- (This is an attempt to support Unicode characters and make sure that they are not broken during transition between files.) -->

<meta charset="utf-8"/>

<!-- CSS -->

<style>

body {
	color: white;
	background-color: black;
}

#blankDocumentText {
	text-align: center;
	font-size: 20px;
}

#printText {
	text-align: center;
	font-size: 20px;
}

#fileButton {
	font-size: 25px;
	text-align: center;
	display: block;
	width: 46%;
	margin-left: 25%;
	padding: 2%;
	background-color: white;
	color: black;
	border: 10px ridge black;
}

#fileInput {
	display: none;
}

#documentHeading {
	text-align: center;
}

.chapterHeading {
	text-align: center;
}

.chapterSubHeading {
	text-align: center;
}

.divide {
	text-align: center;
}

.dialogue {
   /* (Empty class to be used for organization) */
}

#footerHolder {
	background-color: inherit;
}

/* This container holds optional UI */
#ui {
	visibility: hidden;
	width: 94%;
	height: 11%;
	position: fixed;
	background-color: inherit;
	color: inherit;
	padding: 1%;
	margin-top: -1%;
	margin-left: 1%;
	border: 2px solid white;
	display: flex;
	font-size: 25px;
	font-weight: bold;
}

/* UI Buttons to the right */
#ui-buttons {
	flex: 0.3;
}

#ui-stats {
	flex: 0.7;
	/*font-size: 22px;*/
	margin-top: 1.5%;
	text-align: center;
}

#ui-name {
	font-size: 30px;
	font-weight: inherit;
}

/* How a UI button should look: */
.ui-button {
	text-align: center;
	font-size: inherit;
	font-weight: inherit;
	padding-left: 10px;
	padding-right: 10px;
	background-color: black;
	border: 2px solid white;
}

/* This container holds the reader and the editor: */
#mainPage {
	display: flex;
	background-color: inherit;
}

/* This container holds the contents of the DDTXT */
#DDTXT {
	background-color: inherit;
	flex: 1;
}

/* DDTXT editor */
#editor {
	margin-top: 8%;
	flex: 0;
	background-color: inherit;
	visibility: hidden;
	display: none;
}

#editor-content {
	width: 48%;
	max-width: 48%;
	height: 70%;
	max-height: 70%;
	position: fixed;
	resize: both;
	/* The editor is always white text on a black background */
	background-color: black;
	color: white;
	/* See scroll-behavior explanation below */
	scroll-behavior: smooth;
}

#editor-ui {
	width: 100%;
	position: fixed;
	display: flex;
}

#summary {
	width: 120%;
	height: 125%;
	visibility: hidden;
	position: fixed;
	margin-left: -10%;
	margin-top: -10%;
	background-color: black;
}

#summary-content {
	font-size: 20px;
	position: fixed;
	width: 80%;
	height: 60%;
	/* Half of 100% - 80% is 10%. We add 10% to that to counteract the division being 120% of both dimensions. (20%)
	Then, we have to subtract the padding of both sides of each dimension (2 x 2% = 4%), leaving us with 16% */
	margin: 16%;
	padding: 2%;
	background-color: black;
	color: white;
	border: 2px ridge white;
	overflow-y: scroll; /* Only scroll vertically */
}

.summary-character {
	display: flex;
}

.summary-bio {
	flex: 1;
	padding: 1%;
}

.summary-pronouns {
	flex: 1;
	padding: 1%;
}

/* I'm not sure if this (the scroll-behavior attribute) will be supported in older browsers, but it's supported in modern browsers and it should not adversely affect reading on unsupported browsers.
(This makes scrolling gradual instead of linear.) */
html {
	scroll-behavior: smooth;
}

.editor-style {
	border: 2px solid white;
	background-color: darkblue;
}

.editor-style-inner {
	padding: 1%;
	text-align: center;
}

/* @media print holds special cases for printing the webpage */
/* Printing can also mean converting to a PDF, which is the most useful purpose of the following adjustments: */
@media print {
	#footer {
		display: none;
	}
	#ui {
		display: none;
	}
	/* The editor is handled by JS */
	#summary {
		display: none;
	}
	#DDTXT {
		width: 100%;
	}
}

</style>

<head>
	<title id="webpageTitle">DDTXT Reader</title>
</head>

<!-- Fixed UI at top of page -->

<div id="ui">

<!-- Left side -->

<div id="ui-stats"></div>

<!-- Right side -->

<table id="ui-buttons">

<tr id="documentInfo">

<td id="ui-summary" class="ui-button">Summary</td>
<td id="ui-toggle" class="ui-button">Hide stats.</td>

</tr>

</table>

</div>

<!-- Summary box, hidden by default -->

<div id="summary">

<p id="summary-content"></p>

</div>

<div id="mainPage">

<!-- DDTXT editor -->

<div id="editor">
	<table id="editor-ui">
		<tr>
			<td id="editor-save" class="editor-style"><p class="editor-style-inner">Export DDTXT</p></td>
			<td id="editor-refresh" class="editor-style"><p class="editor-style-inner">Refresh DDTXT</p></td>
			<td id="editor-bottom" class="editor-style"><p class="editor-style-inner">Jump to Bottom</p></td>
			<td id="editor-top" class="editor-style"><p class="editor-style-inner">Jump to Top</p></td>
			<td id="editor-close" class="editor-style"><p class="editor-style-inner">Close Editor</p></td>
		</tr>
		<tr>
			<td><textarea id="editor-content" autocomplete="off" spellcheck="off"></textarea></td>
		</tr>
	</table>
</div>

<!-- DDTXT content -->

<div id="DDTXT"></div>

</div>

<!-- Universal footer not dependent on content -->

<div id="footerHolder">

<div id="footer">

<br>

<label id="fileButton" for="fileInput">Read a DDTXT</label>

<input id="fileInput" type="file" accept=".txt, .ddtxt"/>

<p id="blankDocumentText" onclick="createBlankDDTXT()">Click me to open a blank DDTXT.</p>

<p id="printText" onclick="printDDTXT()">Click me to save this DDTXT as a PDF or print it out!<br>(You may have to enable background graphics to get the correct background color.)</p>

</div>

</div> <!-- footerHolder used for flex display -->


<!-- JS -->


<script>

var stringifiedDDTXT = "";

const genericPronounsList = [
	"subject",
	"possessive",
	"object",
	"instance",
	"reflexive",
	"present",
	"presentCompacted",
];

const genericPronouns = {
	["subject"]: "they",
	["possessive"]: "their",
	["object"]: "them",
	["instance"]: "person",
	["reflexive"]: "themselves",
	["present"]: "they are",
	["presentCompacted"]: "they're",
};

// Classes (I just use a function to make an object)
// var newCharacter = new Character();

// Character class used to store character data in the main DDTXT object
var Character = function (
	// The following values are defaults:
	code = "",
	name = "Unnamed Character",
	pronouns = genericPronouns,
	usePluralVerbForm = false,
	content = "There is no biographic summary present.",
	color = "inherit",
	paragraphColor = "inherit",
	backgroundColor = "none",
	dialoguePadding = 0, // In percents
) {
	this.name = name;
	this.code = code;
	this.pronouns = pronouns;
	// Check to make sure we have each pronoun. If not, use the generic form:
	for (index of genericPronounsList) {
		if (!this.pronouns [index]) {
			this.pronouns [index] = genericPronouns [index];
		}
	}
	this.usePluralVerbForm = usePluralVerbForm;
	this.bio = content;
	// Create an empty style subnode:
	this.style = {};
	// Move all CSS style values (colors) to the style subnode:
	this.style.color = color;
	this.style.paragraphColor = paragraphColor;
	this.style.backgroundColor = backgroundColor;
	this.style.dialoguePadding = (typeof(dialoguePadding)) ? parseFloat(dialoguePadding) : dialoguePadding; // In case the input is a numerical string, parse it.
	
	// Grab a style element for this character's dialog:
	const CSSAccess = document.createElement("style");
	CSSAccess.type = "text/css";
	// Character tag:
	CSSAccess.innerHTML += "\n.character-" + this.code + " {\n\tcolor: " + this.style.color + ";\n\tbackground-color: " + this.style.backgroundColor + ";\n\tfont-weight: bold;\n\tpadding: " + dialoguePadding + "%;\n}";
	// Character dialog:
	CSSAccess.innerHTML += "\n.dialog-" + this.code + " {\n\tcolor: " + this.style.paragraphColor + ";\n\tbackground-color: " + this.style.backgroundColor + "\n\tpadding: " + dialoguePadding + "%;\n}";
	// Push this style node to the internal head of the webpage: (Imagine pasting this generated text into this source file's CSS style node)
	document.getElementsByTagName("head") [0].appendChild(CSSAccess);
	
	// Methods:
	
	// Generate a string table of the character's pronouns:
	this.pronounsToString = function () {
		return "Subject: " + this.pronouns.subject + "\nPossessive: " + this.pronouns.possessive + "\nReflexive: " + this.pronouns.reflexive + "\nObject: " + this.pronouns.object + "\nPresent Linking Verb: " + this.pronouns.present + "\nPresent Linking Verb (Contraction): " + this.pronouns.presentCompacted + "\nIs Instance of: " + this.pronouns.instance;
	}
	
	// Print a character to the console:
	this.toString = function () {
		const header = "Character " + this.name + " AKA (" + this.code + ")\n";
		const values = "\nusePluralVerbForm: " + this.usePluralVerbForm + "\nstyle.color: " + this.style.color + "\nstyle.paragraphColor: " + this.style.paragraphColor + "\nstyle.backgroundColor: " + this.style.backgroundColor + "\nstyle.padding: " + this.style.padding;
		return header + values + "\n\n--- Pronouns ---\n\n" + this.pronounsToString() + "\n\n--- Biography ---\n\n" + this.bio;
	}
};


// Chapter class used to store chapter data in the main DDTXT object
var Chapter = function (
	name = "Untitled Chapter",
	subtitle = "",
	content = "",
) {
	// If "none" is used, don't include it
	this.name = (name === "none") ? "" : name;
	this.subtitle = (subtitle === "none") ? "" : subtitle;
	this.text = content;
};



const DDTXTHeader = "<!DOCTYPE DDTXT>";

var DDTXT = {}; // Empty container (for now)

// File information: (Saved upon loading a file)
var sourceFileName = "untitled.ddtxt";
var sourceFileTime = null;

const characterReferences = [
	"@", // Character's name: @test went to the store. => Test Character went to the store.
	"=", // Belonging to character, possessive: It was =test store. => It was their store.
	"+", // Belonging to character using character's name, same as @character's, although this syntax does not work: +test => Test Character's
	"<", // Subject: <test did it! => They did it!
	">", // Object: The ball was thrown to >test => The ball was thrown to them.
	"~", // Instance, generally what a character physically (or similarly) is: @test is a ~test. => Test Character is a ???. NOTE: This one is inherently much more loose and can cause problems if not used with care.
	"*", // Reflexive: @test had to feed *test. => Test Character had to feed themselves.
	"{", // Present progressive: {test walking quickly! => They are walking quickly!
	"}", // Present progressive contraction: }test walking quickly! => They're walking quickly!
	"&", // Verb conjugation help, splices words to conform to grammar given the character's subject form. NOTE: This uses the most recent reference before this one which means that you must use a reference before using this! : <test walk&s to the store => they walk to the store / he/she/etc... walks to the store 
];

// What to consider punctuation:
const punctuation = [
	",",
	".",
	":",
	";",
	"\"",
	"\'",
	"?",
	"!",
];

// Characters that get spaces added after them if not already present:
const spacedPunctuation = [
	",",
	".",
	":",
	";",
	"?",
	"!",
];

// Characters that are considered the beginning of a sentence:
const newSentencePunctuation = [
	".",
	"!",
	"?",
	"[",
	"]",
	"\n"
];

// Characters that are considered to not be part of reference codes, even if they are directly connected to the code @james). -> @james
const charactersNotAllowedInCodes = [
	".",
	",",
	";",
	"[",
	"]",
	"(",
	")",
	"!",
	"?",
	"\"",
	"\'",
];

// Only keep the contents of a string BEFORE disallowed characters, assuming that the beginning of the string is fine.
var trimStringToValidPart = function (disallowedChars, string) {
	var tempString = string;
	
	for (var currentChar = 0; currentChar < disallowedChars.length; currentChar ++) {
		const badCharacter = tempString.indexOf(disallowedChars [currentChar]);
		
		if (badCharacter > -1) { // If a "banned" character is present,
			tempString = tempString.substring(0, badCharacter); // then only keep the part before the character.
		}
	}

	return tempString;
};

// Return the correct part and the trimmed part, in case we need it too  
var trimAndRetainStringToValidPart = function (disallowedChars, string) {
	const tempString = trimStringToValidPart(disallowedChars, string); // Use the function above to trim the string.
	return [tempString, string.substring(tempString.length, string.length)]; // Then, using the length to find what was cut, give us the part that was trimmed.
};

var clearDDTXT = function () {
	// The following object should be used as the definition of the DDTXT object.
	// All of these values are default values.
	DDTXT = {
		style: {
			color: "black",
			titleColor: "inherit",
			headingColor: "inherit",
			backgroundColor: "white",
			divideSize: "50px",
			divide: "~~~",
			divideColor: "inherit",
			break: "<br><br>",
		},
		errorContextLength: 50, // How much text errors should provide follwing an error (so that people can read where the error happened)
		addMissingSpaces: true, // Whether or not the DDTXT parser should append needed spaces after most punctuation.
		// NOTE: (addMissingSpaces = true) is a good idea because it maintains consistency no matter how the DDTXT is spaced out.
		global: {
			name: "Untitled DDTXT",
			webtitle: "",
			author: "Unknown Author",
			summary: "There is no summary present.",
			provideTableOfContents: false, // Whether the document will get an automatic table of contents.
			allowBracketLiterals: false, // Whether the parser can literalize square brackets with dollar signs. (NOTE: Hashtags will always literalize square brackets as they are specific and emphatic.)
			lastModified: null,
			filename: "untitled.ddtxt",
		},
		// This object holds character information
		cast: {
			characters: {}, // Empty list to be filled with characters
			lastCharacterReferenced: "",
			lastReferenceType: "",
			getCharacterByCode: function (code, context) {
				code = code.split(".") [0]; // If bad concatenation results in two sentences getting smooshed together, only use the part of the code before the period (this code works whether there is a period or not.
				// Allow for implicit character references (shorthand for referencing the same character multiple times in a row)
				if (code === "") { // Shorthand (there is no character code)
					if (DDTXT.cast.lastCharacterReferenced !== "") {
						code = DDTXT.cast.lastCharacterReferenced; // Use the previously referenced character as a reference (redundancy)
					}
					else {
						console.error("DDTXTReferenceError: There was an attempt to use shorthand with no previous character to go by! Please reference a character at least once before using this shorthand." + context);
						return new Character();
					}
				}
				// Standard search:
				const result = DDTXT.cast.characters [code];
				
				if (result) {
					return result;
				}
				else {
					console.error("DDTXTReferenceError: Character of code \"" + code + "\" does not exist or has not been registered." + context);
					return new Character();
				}
			},
			// Capitalize a string
			capitalizeWord: function (word) {
				return word [0].toUpperCase() + word.substring(1, word.length);
			},
			// See if a spot is the first word of a sentence
			isFirstWordOfSentence: function (spot, text, withinDialogue = false) {
				// Check for stupid cases first:
				if (spot === 0 || newSentencePunctuation.includes(text [spot - 1])) {
					return true;
				}
				
				spot --; // We've already checked the first character back, so move on
				
				while (spot > 0) {
					// Once you hit a space, assume you are outside of the original word you started at and check for punctuation
					if ([" ", "\t"].includes(text [spot - 1])) {
						spot --;
					}
					else if (newSentencePunctuation.includes(text [spot - 1]) || (withinDialogue && text [spot - 1] === ":")) { // There is an end to a sentence before (for dialogue the colon acts as a division)
						return true; // This should allow truthiness to work
					}
					else { // There is a regular word before
						return false;
					}
				}
			},
			// TODO: THIS FOLLOWING FUNCTION DOES NOT WORK!!
			// THIS IS MERELY A STARTING POINT
			getCompleteWordFromMiddle: function (spot, text, withinDialogue = false) {
				const originalSpot = spot; // Save this for later to avoid checking characters we have already checked
				
				// Check for stupid cases first:
				if (spot === 0 || newSentencePunctuation.includes(text [spot - 1])) {
					return text.substring(0, 0);
				}
				
				spot --; // We've already checked the first character back, so move on
				var start = -1;
				var end = -1;
				
				// Find the start
				while (spot > 0) {
					// Once you hit a space, assume you are outside of the original word you started at
					if ([" ", "\t"].includes(text [spot - 1]) || punctuation.includes(text [spot - 1])) { // Punctuation acts as the end of a word
						start = spot;
						break;
					}
					else { // Skip alphanumeric characters
						spot --;
					}
				}
				
				// Reset the seeker
				spot = originalSpot;
				
				// Find the end
				while (spot < text.length - 1) {
					// Once you hit a space, assume you are outside of the original word you started at
					if ([" ", "\t"].includes(text [spot + 1]) || punctuation.includes(text [spot + 1])) { // Punctuation acts as the end of a word
						end = spot;
						break;
					}
					else { // Skip alphanumeric characters
						spot ++;
					}
				}
				
				return text.substring(start + 1, end);
			},
			// Convert an already known reference type and a known code to the correct pronoun and/or character information
			// spot, fullText, and withinDialogue parameters are used for debugging and context
			getCharacterPronounByCode: function (code, referenceCharacter, spot, fullText, withinDialogue = false) {
				const DDTXTCharacter = DDTXT.cast.getCharacterByCode(((referenceCharacter === "&") ? "" : code), " (This problem occurs around the following: \"" + fullText.substring(spot, spot + DDTXT.errorContextLength) + "\")"); // If the reference is a verb form checker (&), then pass through an empty string (which means reuse the previous code)
				
				const referenceToPronoun = {
					["="]: "possessive",
					[">"]: "object",
					["<"]: "subject",
					["~"]: "instance",
					["*"]: "reflexive",
					["{"]: "present",
					["}"]: "presentCompacted",
				};
				// Unique cases
				if (referenceCharacter === "&") { // Verb forms
					if (DDTXT.cast.lastCharacterReferenced !== "") {
						return (DDTXT.cast.lastReferenceType !== "@" && DDTXTCharacter.usePluralVerbForm) ? "" : code; // "code" here is the letters that should be used for the singular form of the verb. This ternary handles most cases of verb conjugations.
						// If ((the character always uses plural verb form) or (the most recent reference is not the character's name)) then omit the extra letters of the verb.
					}
					else {
						console.error("DDTXTReferenceError: There was an attempt to use shorthand with no previous character to go by! Please reference a character at least once before using this shorthand.");
						return "";
					}
				}
				
				// Save the last reference type:
				DDTXT.cast.lastReferenceType = referenceCharacter;
				if (code !== "") { // Don't overwrite the character code when using shorthand. That would be silly because it would set the last character to an empty string after the first time.
					DDTXT.cast.lastCharacterReferenced = code;
				}
				
				// More unique cases
				if (referenceCharacter === "@") { // Name
					return DDTXTCharacter.name;
				}
				else if (referenceCharacter === "+") { // Possessive name (Emily's)
					const name = DDTXTCharacter.name;
					return (name [name.length - 1] === "s") ? name + "\'" : name + "\'s"; // The ternary here handles apostrophes following an s
				}
				// Standard
				else {
					// Lookout for capitalization at the beginning of sentences:
					var result = DDTXTCharacter.pronouns [referenceToPronoun [referenceCharacter]];
					if (DDTXT.cast.isFirstWordOfSentence(spot, fullText, withinDialogue)) {
						result = DDTXT.cast.capitalizeWord(result);
					}
					// Return the final answer
					return result;
				}
			},
			// Call this function to convert character references into actual words
			convertReference: function (text, start, referenceCharacter, withinDialogue = false) {
				var word = text.substring(start, text.length).split(" ") [0]; // Pull out the first word of the string
				const totalOriginalLength = word.length + 1; // Save the original word length for later use.
				// Make sure the code does not have bad characters, saving them to add back in later:
				const trimData = trimAndRetainStringToValidPart(charactersNotAllowedInCodes, word); // The code is now only the usable portion of the original code, with the unusable portion saved to add back in upon return.
				// Assign the results of the above function:
				word = trimData [0]; // Trim the original word to the new code
				const extra = trimData [1]; // Hold the extra characters here for future use.
				// Return the reference and the extra characters:
				return text.substring(0, start - 1) + DDTXT.cast.getCharacterPronounByCode(word, referenceCharacter, start, text, withinDialogue) + extra + text.substring(start + totalOriginalLength - 1, text.length); // Old + converted text + extra text not used + future
			},
			// This formats all DDTXT syntax other than (hardbaked) segments, which require the simpler format() function below
			formatChunk: function (text) {
				var withinBrackets = false;
				var lastSpot = -1;
				var charactersShifted = 0;
				
				// Character reference and hashtag pass-through:
				
				for (var currentChar = 0; currentChar + charactersShifted < text.length; currentChar ++) {
					const spot = currentChar + charactersShifted;
					
					// Ascertain whether we are in HTML or not:
					
					// Ascertain whether we are in dialogue or not:
					if (["[", "]"].includes(text [spot]) && text [spot - 1] !== "#") {
						withinBrackets = !withinBrackets; // Toggle where we are upon either of these (this could break, but it'll work with appropiate bracket usage)
					}
					
					
					// Format character references:
					
					
					if (characterReferences.includes(text [spot])) {
						// Example of input:
						// 0 1 2 3 4 5
						// 5 # + 8 # =
						
						// Remove all hashtags and skip the next character.
						if (text [spot - 1] === "#") {
							text = text.substring(0, spot - 1) + text.substring(spot, text.length);
							charactersShifted --; // Remove a character from the seeker.
							// Skip the next character (since we already have it covered).
							currentChar ++;
						}
						else {
							const originalLength = text.length;
							text = DDTXT.cast.convertReference(text, spot + 1, text [spot], withinDialogue = withinBrackets); // The +1 in the middle omits the reference character from the character code. withinDialogue tells the conversion function to count a colon as a new sentence.
							charactersShifted += text.length - originalLength;
						}
					}
					
					// Special case: dollar sign used to skip the parser past a word (for example, links)
					if (text [spot] === "$" && text [spot - 1] !== "#") {
						const currentWord = text.substring(spot, text.length).split(" ") [0]; // Stop after the next space
						var wordShift = 0; // I'm trying an internal shift in addition to the external shift.
						
						// Convert any hashtags to literalized hashtags so they are not removed
						for (var currentWordChar = 1; currentWordChar < currentWord.length + wordShift; currentWordChar ++) {
							// const wordSpot = currentWordChar + wordShift + spot; // I'm trying an internal shift in addition to the external shift.
						
							// We start at 1 because 0 is the dollar sign
							if (text [spot + currentWordChar] === "#") {
								text = text.substring(0, spot + currentWordChar) + "#" + text.substring(spot + currentWordChar, text.length);
								charactersShifted ++; // Shift the index forward
								currentWordChar ++; // Shift the text seeker one forward for the added character
								currentChar ++; // and one forward becuase we know what the next character is
							}
							
							
							// I'm working on getting this code to replace brackets within a literalized word
							
							if (DDTXT.global.allowBracketLiterals) {
								if (text [spot + currentWordChar] === "[") {
									text = text.substring(0, spot + currentWordChar) + "(left bracket)" + text.substring(spot + currentWordChar, text.length);
									// wordShift += ("left bracket").length; // Shift the index forward
									currentWordChar += ("left bracket").length; // Shift the text seeker forward for the added characters
									currentChar += ("left bracket").length; // and shift the  forward becuase we know what the next character is
								}
								// The else if stops more than one bracket being handled at once
								else if (text [spot + currentWordChar] === "]") {
									text = text.substring(0, spot + currentWordChar) + "(right bracket)" + text.substring(spot + currentWordChar, text.length);
									// wordShift += ("right bracket").length; // Shift the index forward
									currentWordChar += ("right bracket").length; // Shift the text seeker one forward for the added character
									currentChar += ("right bracket").length; // and one forward becuase we know what the next character is
								}
							}
							
						}
						
						// Skip the parser that many characters, removing a character for the dollar sign that we are removing
						currentChar += currentWord.length;
						charactersShifted --;
						// Remove the dollar sign
						text = text.substring(0, spot) + text.substring(spot + 1, text.length);
					}
				}
				
				// Now that all references have been converted, any remaining <s and >s can be converted to the HTML friendly &lt; and &gt; respectively:
				text = text.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
				
				// Replace all double hashtags with a single hashtag.
				// This is not covered above since the if clause is not triggered.
				// (A commenting hashtag would be paradoxically confused with a double hashtag.)
				
				text = text.replaceAll("##", "(hashtag)");
				
				// Replace all literalized brackets.
				
				text = text.replaceAll("#[", "(left bracket)");
				text = text.replaceAll("#]", "(right bracket)");
				
				// Remove unused single hashtags.
				
				text = text.replaceAll("#", "");
				
				// text = text.replaceAll("(hashtag)", "#"); Covered by DDTXT In-text commands below
				
				// Same for quote marks, which should be converted to the more HTML friendly "&quot;":
				
				text = text.replaceAll("\"", "&quot;");
				
				// Quote pass-through
				
				charactersShifted = 0;
				withinBrackets = false; // (THIS SHOULD BE FALSE ANYWAY, but someone's bound to make a typo at some point. (Me))
				
				for (var currentChar = 0; currentChar + charactersShifted < text.length; currentChar ++) {
					const spot = currentChar + charactersShifted;

					if (!withinBrackets && text [spot] === "[") {
						withinBrackets = true;
						lastSpot = currentChar; // Save this spot, EXCLUDING the shift that we add later
					}
					else if (withinBrackets && text [spot] == "]") {
						withinBrackets = false;
						const dialog = splitLineAtFirst(text.substring(lastSpot + 1 + charactersShifted, spot), ":"); // Pull out the dialog and split it into both parts, assuming any extra colons are part of the dialog.
						// Syntax error handling
						if (dialog.length < 2) {
							console.error("DDTXTSyntaxError: Character dialog does not have a colon around \"" + dialog [0] + "\"");
							return text;
						}
						
						// Calculate the length of the original text representing dialogue
						const totalOriginalLength = dialog [0].length + dialog [1].length + 3; // The +2 includes the brackets as part of the length and the other +1 keeps the seeker on track
						
						// Character code
						const characterCode = (dialog [0].trim() === "") ? DDTXT.cast.lastCharacterReferenced : dialog [0].trim(); // If shorthand is in use, use the last character referenced.
						
						// Dialog
						const spokenWords = dialog [1].trim();
						
						var htmlDialog;
						
						// Formal character name seen by readers.
						var characterName;
						// Determine character name:
						if (characterCode.substring(0, 9) === "(hashtag)") {
							characterName = characterCode.substring(9, characterCode.length)
						}
						else if (characterCode.toLowerCase() === "href") {
							characterName = characterCode.substring(1, characterCode.length)
						}
						else {
							characterName = DDTXT.cast.getCharacterByCode(characterCode).name;
						}
						// If the name begins with a hashtag (which at this point has been converted to a DDTXT command), that means that it has been casted in, and therefore does not exist. In this case, use the name provided, removing the hashtag at the beginning (substring).
						
						// Proper, formal HTML text:
						// If the "dialog" is a link, don't format it. Simply return the string as a link that opens in a new tab be default:
						// (links that open in the same tab annoy me)
						if (characterCode.toLowerCase() === "href") {
							var linkAddress = spokenWords;
							var linkText = spokenWords;
							var linkMode = "_blank"; // Open in a new tab
							
							// By this point, all hashtags will be removed or converted to "(hashtag)", so we must check for that instead of the symbol.
							
							if (spokenWords.substring(0, 9) === "(hashtag)") {
								// (Hashtags specify destinations within the document according to HTML standards.)
								
								// Replace the (hashtag) command with the symbol for use as a link:
								linkAddress = "#" + linkAddress.substring(9, linkAddress.length);
								
								if (linkAddress.substring(1, 9) === "chapter-" && (parseInt(linkAddress.substring(8, linkAddress.length)) !== NaN)) { // If the link is going to a chapter and there is a number after the hyphen/dash (-), then format the link text that the reader sees.
									linkText = "(Go to Chapter " + linkAddress.split("-") [1] + ")";
								}
								linkMode = "_self"; // Don't open a new tab since that doesn't have the DDTXT loaded
								try {
									document.getElementById(linkAddress);
								}
								catch {
									console.log("DDTXTLinkError: Link unreadable! Links to other chapters must be in the form chapter-X, where X is the chapter number with no leading zeroes. This is case sensitive (6 is fine, but 006 is not fine.)");
								}
							}
							// Standard link using target mode, address, and text to display:
							htmlDialog = "<a target=\"" + linkMode + "\" href=\"" + linkAddress + "\">" + linkText + "</a>";
						}
						// Regular dialogue:
						else {
							// Apparently, to add multiple classes to an HTML element, you only have to add a space between the classes.
							htmlDialog = "<h3 class=\"dialogue character-" + characterCode + "\">" + characterName + ": <nothing class=\"dialog-" + characterCode + "\">" + spokenWords + "</nothing></h3>";
						}
						
						// Prepare the ends:
						const previousText = text.substring(0, lastSpot + charactersShifted);
						const finalText = text.substring(lastSpot + charactersShifted + totalOriginalLength, text.length);
						
						text = previousText + htmlDialog + finalText; // Apply changes to text, ready for further parsing
						lastSpot = -1; // Clear the most recent open bracket
						
						// Make sure to ignore extra added text characters
						charactersShifted = charactersShifted - totalOriginalLength + htmlDialog.length; // charactersShifted will probably be a negative number.
						// Save this character reference for future shorthand:
						DDTXT.cast.lastCharacterReferenced = characterCode;
					}
					// End of quote parsing
				}
				
				// Divide pass-through
				
				const literalDivideText = "<h2 class=\"divide\" style=\"font-size: " + DDTXT.style.divideSize + "; color: " + DDTXT.style.divideColor + "\">" + DDTXT.style.divide + "</h2>";
				
				text = text.replaceAll("(divide)", literalDivideText);
				
				// Break line pass-through
				
				text = text.replaceAll("(break)", DDTXT.style.break); // Replace all breaks with the actual HTML <br>, which is impossible in the DDTXT without using this command.
				
				// Em dash pass-through
				
				text = text.replaceAll("(em dash)", "â€”");
				
				// Horizontal rule pass-through
				
				text = text.replaceAll("(horizon)", "<hr>");
				
				// Special character commands:
				
				const replaceKeyword = [
					// 0
					"(at symbol)",
					// 1
					"(equal symbol)",
					// 2
					"(less than symbol)",
					// 3
					"(greater than symbol)",
					// 4
					"(asterisk symbol)",
					// 5
					"(tilde symbol)",
					// 6
					"(left curly brace)",
					// 7
					"(right curly brace)",
					// 8
					"(left bracket)",
					// 9
					"(right bracket)",
					// 10
					"(dollar sign)",
					// 11
					"(hashtag)",
					// (These two come last so that you can write commands without actually using them.)
					// 12
					"(left parenthesis)",
					// 13
					"(right parenthesis)"
				];
				
				const replaceWith = [
					// 0
					"@",
					// 1
					"=",
					// 2
					"<",
					// 3
					">",
					// 4
					"*",
					// 5
					"~",
					// 6
					"{",
					// 7
					"}",
					// 8
					"[",
					// 9
					"]",
					// 10
					"$",
					// 11
					"#",
					// 12
					"(",
					// 13
					")"
				];
				
				// Use the above tables to replace the keywords with the symbols
				
				for (var currentSymbol = 0; currentSymbol < replaceKeyword.length; currentSymbol ++) {
					text = text.replaceAll(replaceKeyword [currentSymbol], replaceWith [currentSymbol]);
				}
				
				// Final steps
				
				if (withinBrackets) { // Check for weird syntax problems
					console.error("DDTXTSyntaxError: Character dialog has not been closed off around \"" + text.substring(0, DDTXT.errorContextLength) + "\".");
				}
				
				return text;
			},
			// Call this function to convert formatted DDTXT text to literal HTML text
			format: function (text) {
				// Convert all HTML segment ends to beginnings, since we are going to use a simple split:
				text.replaceAll("(/hardbaked)", "(hardbaked)");
				// Simply split by "(hardbaked)"s
				const textChunks = text.split("(hardbaked)");
				
				tempString = ""; // Create a temp string to concatenate to.
				
				for (currentChunk = 0; currentChunk < textChunks.length; currentChunk ++) { // Append each chunk, formatting, excluding odd chunks from formatting
					if (currentChunk % 2 === 1) {
						tempString += "<pre>" + textChunks [currentChunk].replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("&", "&amp;") + "</pre>";
						// Convert all tags to their stringified equivalent and 
					}
					else {
						tempString += DDTXT.cast.formatChunk(textChunks [currentChunk]);
					}
				}
				
				return tempString;
			},
		},
		// List to be filled with the document's Chapters
		chapters: [
			
		],
	};
};

var HTMLFormat = ""; // To be filled with the literal HTML version of the DDTXT

// Reference to the HTML file input object
const inputReference = document.getElementById("fileInput");

// Apply the DDTXT's style to the webpage's CSS.
var updateBodyCSS = function () {
	const DDHTMLText = document.getElementById("DDTXT"); // Grab the body element
	// Update DDTXT background color:
	DDHTMLText.style.backgroundColor = DDTXT.style.backgroundColor;
	// Update basic DDTXT text color:
	DDHTMLText.style.color = DDTXT.style.color;
	// Update footer
	const footer = document.getElementById("footer");
	footer.style.backgroundColor = DDTXT.style.backgroundColor;
	footer.style.color = DDTXT.style.color;
	document.getElementById("footerHolder").style.backgroundColor = DDTXT.style.backgroundColor;
	// Update UI colors
	// Fixed document header
	const header = document.getElementById("ui");
	header.style.backgroundColor = DDTXT.style.backgroundColor;
	header.style.color = DDTXT.style.color;
	header.style.border = "2px solid " + DDTXT.style.color;
	// Update UI buttons:
	// Obtain access to the document's Cascading Style Sheets.
	const CSSAccess = document.createElement("style");
	CSSAccess.type = "text/css";
	// Now, append information to the access.
	CSSAccess.innerHTML = ".ui-button {\n\tborder: 2px solid " + DDTXT.style.color + ";\n}";
	//
	// .ui-button {
	// 	border: 2px solid COLOR;
	// }
	//
	// Push the access to the actual document.
	document.getElementsByTagName("head") [0].appendChild(CSSAccess);
	// These two are meant to be different. One is a container and the other is the styling class for the buttons.
	document.getElementById("ui-buttons").style.backgroundColor = DDTXT.style.backgroundColor;
	// Update editor background color
	document.getElementById("editor").style.backgroundColor = DDTXT.style.backgroundColor;
	// Update toggle button color
	document.getElementById("ui-toggle").style.backgroundColor = DDTXT.style.backgroundColor;
	// Summary toggle button color
	document.getElementById("ui-summary").style.backgroundColor = DDTXT.style.backgroundColor;
	// Summary content colors
	const summaryContent = document.getElementById("summary-content");
	summaryContent.style.backgroundColor = DDTXT.style.backgroundColor;
	summaryContent.style.color = DDTXT.style.color;
	summaryContent.style.border = "2px ridge " + DDTXT.style.color;
	// Update webpage colors
	document.getElementById("mainPage").style.backgroundColor = DDTXT.style.backgroundColor;
	document.documentElement.style.backgroundColor = DDTXT.style.backgroundColor;
	document.documentElement.style.color = DDTXT.style.color;
};

// Create literal HTML character biographies:
var generateHTMLCharacterBiographies = function () {
	tempString = "<h1 style=\"text-align:center\">Character Descriptions:</h1>";
	// Make one for each character:
	for (const characterCode in DDTXT.cast.characters) {
		// Center the character's name and color it the character's color.
		// In addition, put a border around the pronouns table according to the DDTXT's text/detail color.
		const character = DDTXT.cast.getCharacterByCode(characterCode);
		tempString += "<h2 style=\"text-align: center\" class=\"character-" + characterCode + "\">" + character.name + "</h2><div class=\"summary-character\"><p class=\"summary-bio\">" + DDTXT.cast.format(character.bio) + "</p><p style=\"border: 2px solid " + DDTXT.style.color + "\" class=\"summary-pronouns\">" + character.pronounsToString().replaceAll("\n", "<br>") + "</p></div>";
	}
	return tempString;
};

// Create literal HTML content for the summary box to use:
var generateHTMLSummaryText = function () {
	const lastModifiedDate = new Date(DDTXT.global.lastModified); // Convert the integer to a Date object
	const characterBios = generateHTMLCharacterBiographies();
	return DDTXT.cast.format(DDTXT.global.summary) + "<hr>by <em>" + DDTXT.global.author + "</em><hr>Last modifed on " + lastModifiedDate.toDateString() + ", " + lastModifiedDate.toTimeString() + "<br>under " + DDTXT.global.filename + "<hr>(Click anywhere to close this summary.)" + characterBios + "<br><p style=\"text-align: center\">(Click anywhere to close this summary.)</p>"; // Return the entire summary box
};

// Create DDTXT content for the table of contents to be formatted upon convertDDTXTToHTML():
var generateTableOfContents = function () {
	var chapterText = "";
	for (var currentChapter = 0; currentChapter < DDTXT.chapters.length; currentChapter ++) {
		chapterText += "(Chapter " + (currentChapter + 1) + ") " + DDTXT.chapters [currentChapter].name + ": [href: ##chapter-" + (currentChapter + 1) + "](break)";
	}
	return chapterText;
};

// Take the loaded DDTXT and convert each chapter's formatted DDTXT content to the literal HTML webpage
var convertDDTXTToHTML = function () {
	const DDHTMLText = document.getElementById("DDTXT");
	
	HTMLFormat = ""; // Clear the HTML formatted text
	
	// Append space before for the fixed UI at the top
	HTMLFormat += "<br><br><br><br><br>";
	
	// Append the document header first
	if (DDTXT.global.name !== "" || DDTXT.global.author !== "") { // If a title or author is defined, attach the DDTXT document header:
		HTMLFormat += "<h1 id=\"documentHeading\" style=\"color: " + DDTXT.style.titleColor + "\">" + DDTXT.cast.format(DDTXT.global.name) + "</h1><h2 style=\"text-align: center; color: " + DDTXT.style.titleColor + "\">by " + DDTXT.global.author + "</h2><br>";
	}
	
	// If there should be a table of contents, then generate that first:
	if (DDTXT.global.provideTableOfContents) {
		const tableOfContents = generateTableOfContents(); // Get generated table of contents in DDTXT format
		HTMLFormat += "<h1 class=\"chapterHeading\" id=\"chapter-0\" style=\"color: " + DDTXT.style.headingColor + "\">Table of Contents</h1><br><p style=\"text-align: center; font-size: 20px\">" + DDTXT.cast.format(tableOfContents) + "</p>";
	}
	
	// Keep track of the numerical identity of each chapter
	var chapterNumber = 0;
	
	// Append each chapter to the webpage (DDTXT.cast.format() does most of the work here)
	for (const chapter of DDTXT.chapters) {
		chapterNumber ++; // Increment the tracker (this starts at 1 since we do it before anything else)
		HTMLFormat += "<br><h1 class=\"chapterHeading\" id=\"chapter-" + chapterNumber + "\" style=\"color: " + DDTXT.style.headingColor + "\">" + DDTXT.cast.format(chapter.name) + "</h1><h2 class=\"chapterSubHeading\" style=\"color: " + DDTXT.style.headingColor + "\">" + DDTXT.cast.format(chapter.subtitle) + "</h2><br><p>" + DDTXT.cast.format(chapter.text) + "</p>";
	}
	
	// Add a final space to provide more breathing room on the webpage:
	HTMLFormat += "<br>";
	
	// Push HTML to the webpage:
	DDHTMLText.innerHTML = HTMLFormat;
	
	updateBodyCSS(); // Update global CSS as defined in DDTXT document
};

// Basic conversion to boolean: (Does Boolean(value) do the same? IDK)
var toBool = function (value) {
	// Use boolean evaluations to handle these two data types:
	if (typeof(value) === "string") {
		return (value.trim().toLowerCase() === "true");
	}
	else if (typeof(value) === "number") {
		return (value === 1);
	}
};

// Parsing modes (track what we are looking at)

const NONE = -1;
const CHARACTER = 0;
const CHAPTER = 1;
const GLOBAL = 2;

// Convert mode numbers to string for debugging (simple index)
const parseTypes = [
	"NONE",
	"character",
	"chapter",
	"global",
];

// Sub types:

const STYLE = 0;
const PRONOUNS = 1;

// Convert mode numbers to string for debugging (simple index)
const subParseTypes = [
	"style",
	"pronouns",
];

// Text types:

const HARDBAKED = 0;

// Variables for keeping track of limited parsing possibilites:
var parseType = NONE; // Current main node type (global, chapter, ect...)
var subParseType = NONE; // Current sub node type (style, ect...)
var currentlyInTextNode = false; // Whether or not we are in a text sub node, which can be almost anywhere
var textBuffer = ""; // The text within the current text sub node
var currentNode = {}; // The information within the current node
var currentSubNode = {}; // The information within the current sub node
var textMode = NONE; // The overall way the DDTXT is interpreted. Right now, hardbaked (no DDTXT interpretation), and normal (regular DDTXT interpretation)

// Data types accepted in the DDTXT format:
const dataTypes = [
	"name",
	"subtitle",
	"code",
	"color",
	"backgroundColor",
	"paragraphColor",
	"dialoguePadding",
	"webtitle",
	"author",
	"provideTableOfContents",
	"allowBracketLiterals",
	"divide",
	"divideSize",
	"divideColor",
	"break",
	"titleColor",
	"headingColor",
	// Character pronouns:
	"subject",
	"possessive",
	"object",
	"instance",
	"reflexive",
	"present",
	"presentCompacted",
];

// Only split the string at the first instance of the splitting point, leaving the other instances connected
var splitLineAtFirst = function (text, splitSignal) {
	const spot = text.indexOf(splitSignal);
	if (spot !== -1) { // If we can split (index is not -1, which would signal not found)
		return [(spot === 0) ? "" : text.substring(0, spot), text.substring(spot + splitSignal.length, text.length)]; // Return both parts, returning an empty string before the split if there is nothing before the split
	}
	else {
		return [text]; // Much like the String.split() function, always return a list, even on returning original input
	}
};

// Interpret a single trimmed line as data
var parseDDTXTLine = function (line, lineNumber = -1) {
	// Top level
	if (parseType === NONE) {
		if (line === "<character>") {
			parseType = CHARACTER;
			subParseType = NONE;
		}
		else if (line === "<chapter>") {
			parseType = CHAPTER;
			subParseType = NONE;
		}
		else if (line === "<global>") {
			parseType = GLOBAL;
			subParseType = NONE;
		}
		else if (line [0] !== "<") { // Line is not a tag, therefore it is assignment information not going anywhere:
			console.error("DDTXTNodeError: Misplaced information at the top level at line " + ((lineNumber === -1) ? "UNKNOWN" : lineNumber) + ": \"" + line + "\"");
		}
	}
	// Check for breaking:
	else {
		if (line.substring(0, 2) === "</" && textMode === NONE) { // If the line is breaking a group, then break the group
			// If we are in a text node, then leave the text node (THIS TAKES PRIORITY OVER ALL)
			if (currentlyInTextNode) {
			// Otherwise reset the parse mode (character, chapter, etc..)			
				currentlyInTextNode = false; // Switch text mode off
				currentNode.content = textBuffer; // Copy the buffer to the content to be appended to the next node
				textBuffer = ""; // Clear the buffer
			}
			// If we are in a sub type, go back to the main type:
			else if (subParseType !== NONE) {
				if (subParseType === STYLE) {
					// Global <style> subnode:
					if (parseType === GLOBAL) {
						const defaults = DDTXT.style; // Grab the defaults, in case not all atributes are defined.
						const attributeNames = [ // For iteration:
							"color",
							"backgroundColor",
							"headingColor",
							"titleColor",
							"divide",
							"divideColor",
							"divideSize",
							"break",
						];
						// Copy over any missing attributes to the current sub node:
						for (var index = 0; index < attributeNames.length; index ++) {
							const attribute = attributeNames [index];
							if (!currentSubNode [attribute]) {
								currentSubNode [attribute] = defaults [attribute];
							}
						}
						const styleCopy = currentSubNode; // Create a deep copy. (A constant has to save a separate, frozen copy of varying information by definition.)
						DDTXT.style = styleCopy; // Move the data over to the DDTXT object
					}
					// Character <style> subnodes are handled fully upon ending the <character> node
					if (parseType === CHARACTER) {
						// If dialogue padding has been specified and it ends with a percent sign, remove it and keep the number:
						const paddingInput = currentSubNode.dialoguePadding;
						if (paddingInput) {
							currentSubNode.dialoguePadding = (paddingInput [paddingInput.length - 1] === "%") ? paddingInput.substring(0, paddingInput.length - 1) : paddingInput;
						}
						const styleCopy = currentSubNode; // Create a deep copy
						currentNode.style = styleCopy; // Move the data to the currentNode object
					}
				}
				if (subParseType === PRONOUNS) {
					const pronounsCopy = currentSubNode; // Create a deep copy
					currentNode.pronouns = pronounsCopy; // Move the data to the currentNode object
				}
				currentSubNode = {}; // Clear the current sub node
				subParseType = NONE;
			}
			else {
				// Push stored character information to a new Character
				if (parseType === CHARACTER) {
					if (currentNode.style === undefined) { // If there is no style subnode, create an empty one
						currentNode.style = {}; // Avoid looking inside of nothing, which causes errors
					}
					DDTXT.cast.characters [currentNode.code] = new Character (
						// If these values are undefined the constructor method will use default values.
						code = currentNode.code,
						name = currentNode.name,
						pronouns = currentNode.pronouns, // This is an object (string -> string dictionary)
						usePluralVerbForm = toBool(currentNode.usePluralVerbForm),
						bio = currentNode.content,
						color = currentNode.style.color,
						paragraphColor = currentNode.style.paragraphColor,
						backgroundColor = currentNode.style.backgroundColor,
						dialoguePadding = currentNode.style.dialoguePadding
					);
				}
				// Push stored chapter information to a new Chapter
				if (parseType === CHAPTER) {
					DDTXT.chapters [DDTXT.chapters.length] = new Chapter (
						name = currentNode.name,
						subtitle = currentNode.subtitle,
						content = currentNode.content,
					);
				}
				// Push global data to the DDTXT object
				if (parseType === GLOBAL) {
					DDTXT.global.name = currentNode.name;
					DDTXT.global.webtitle = currentNode.webtitle;
					DDTXT.global.author = (currentNode.author) ? currentNode.author : "Unknown Author"; // Default to "Unknown Author" if the DDTXT does not specify an author
					DDTXT.global.summary = (currentNode.content) ? currentNode.content : "Document summary is not present."; // Default to "Document summary is not present." if the DDTXT does not specify a summary
					DDTXT.global.provideTableOfContents = toBool((currentNode.provideTableOfContents) ? currentNode.provideTableOfContents : false); // Default to false (no Table of Contents provided)
					DDTXT.global.allowBracketLiterals = toBool((currentNode.allowBracketLiterals) ? currentNode.allowBracketLiterals : false); // Default to false (Dollar signs will not literalize square brackets, meaning dialogue will be left untouched.)
				}
				currentNode = {}; // Clear stored node data
				parseType = NONE;
			}
		}
		// Text node "parsing"
		else if (currentlyInTextNode) {
			if (textMode === HARDBAKED) {
				textBuffer += "<br>"; // When text is hardbaked, lines are actually lines (the new lines are kept by DDTXT.cast.format())
			}
			// Hardbaked mode checks:
			if (line === "(/hardbaked)") {
				textMode = NONE;
			}
			else if (line === "(hardbaked)") {
				textMode = HARDBAKED;
			}
			// Regular text addition:
			textBuffer += ((DDTXT.addMissingSpaces && spacedPunctuation.includes(textBuffer [textBuffer.length - 1])) ? " " : "") + line; // Push the text forward to the text buffer, adding an extra space after certain punctuation if not present.
		}
		// Check if a text node is starting:
		else if (line === "<text>") {
			currentlyInTextNode = true; // Toggle text mode on
		}
		// Check if a we are starting one of the following sub nodes:
		else if (subParseType === NONE && line === "<style>") {
			subParseType = STYLE;
		}
		else if (subParseType === NONE && line === "<pronouns>") {
			subParseType = PRONOUNS;
		}
		else {
			// Parse line by line data in a group
			// Indexing constants
			const VARIABLE = 0;
			const VALUE = 1;
			
			// Split the provided line into both sides
			const splitLine = line.split("=");
			
			// Error handling
			if (splitLine.length < 2) {
				console.error("DDTXTAssignmentError: Line " + ((lineNumber === -1) ? "UNKNOWN" : lineNumber) + " does not have an equal sign (\"=\"): \"" + line + "\"");
				return;
			}
			else if (splitLine.length > 2) {
				console.error("DDTXTAssignmentError: Line " + ((lineNumber === -1) ? "UNKNOWN" : lineNumber) + " has an extra equal sign (\"=\"): \"" + line + "\"");
				return;
			}
			
			// Store and trim each side
			const variable = splitLine [VARIABLE].trim();
			const value = splitLine [VALUE].trim();
			
			// If we are in a sub node, then assign this data to the sub node	
			if (dataTypes.includes(variable)) { // If the data type is implemented, then care about it:
				if (subParseType !== NONE) {
					currentSubNode [variable] = value;
				}
				else {
					// Otherwise, assign the data to the currentNode data:
					currentNode [variable] = value;
				}
			}
			
			// End of standard data parsing
		}
	}
};

var performFinalDDTXTChecks = function () {
	// See if the webpage title is defined (default to DDTXT title):
	if (!DDTXT.global.webtitle) { // If we don't have a webtitle
		DDTXT.global.webtitle = (DDTXT.global.name) ? DDTXT.global.name : "DDTXT Reader"; // Use the DDTXT's name, using DDTXT Reader as a last resort.
	}
	// Make sure divide size is formatted appropiately:
	if (DDTXT.style.divideSize.substring(DDTXT.style.divideSize.length - 3, DDTXT.style.divideSize.length - 1) !== "px" && DDTXT.style.divideSize [DDTXT.style.divideSize.length - 1] !== "%") { // If the size does not specify pixels or percent, assume pixels:
		DDTXT.style.divideSize += "px";
	}
	// Always copy this saved value to the file information inside the DDTXT {} object:
	DDTXT.global.filename = sourceFileName;
	DDTXT.global.lastModified = sourceFileTime;
};

var updateExternalText = function () {
	// Update the webpage title:
	document.getElementById("webpageTitle").innerHTML = DDTXT.global.webtitle + " (" + DDTXT.global.filename + ")";
	// Now that we know the last modified date, generate the DDTXT's summary:
	document.getElementById("summary-content").innerHTML = generateHTMLSummaryText();
};

var parseDDTXT = function (text = stringifiedDDTXT) {
	stringifiedDDTXT = text; // In case we don't have the string yet, copy it to a more permanent location
	clearDDTXT(); // Clear the DDTXT again in case we are refreshing and not loading
	//document.getElementById("editor-content").reset(); // Clear the editor's contents.
	document.getElementById("editor-content").innerHTML = stringifiedDDTXT; // Pour the raw document into the editor.
	
	// Break the file into lines:
	const lines = text.split("\n");
	
	if (lines [0] == DDTXTHeader) {
		for (var currentLineIndex = 1; currentLineIndex < lines.length; currentLineIndex ++) { // Read each line
			const line = lines [currentLineIndex].trim(); // Grab the line and trim it
			// If the line is not empty or beginning with a comment identifier, then parse it
			if (!(line === "" || line.substring(0, 2) === "//")) {
				parseDDTXTLine(line, currentLineIndex + 1); // currentLineIndex + 1 is the line number that would be displayed in the actual file
			}
		}
		// Check for syntax errors:
		if (subParseType !== NONE) {
			console.error("DDTXTNodeError: File ends without closing off a " + subParseTypes [subParseType] + " subnode!");
		}
		if (parseType !== NONE) {
			console.error("DDTXTNodeError: File ends without closing off a " + parseTypes [parseType + 1] + " node!");
		}
		if (textMode !== NONE) {
			console.error("DDTXTNodeError: File ends without closing off a hardbaked segment of a text node!");
		}
		performFinalDDTXTChecks();
	}
	else {
		console.error("DDTXTFileError: Current file is not a DDTXT! (The first line must be \"" + DDTXTHeader + "\" exactly.)");
	}
	
	// Print the object to the console. Some web consoles allow for interactive viewing of this information, which allows authors to make sure everything is correct.
	console.log(DDTXT);
	// Having loaded all file contents to the DDTXT object, convert the DDTXT object into a string readable by HTML
	convertDDTXTToHTML();
};

// Open a blank DDTXT, opening the editor (since that's the main purpose of a blank document).
var createBlankDDTXT = function () {
	// Create new file information:
	var alertInput; // Create an input reference.
	// It looks like I'm in the clear here, but I'm going to include this try/catch in case the basic prompt() function is not supported properly or at all, which means that this will still work.
	try {
		alertInput = prompt("Please enter a file name!"); // Grab input.
	}
	catch {
		console.error("The prompt() function is not supported in your browser!");
		alertInput = "";
	}
	
	const newFileName = (typeof(alertInput) !== "string" || alertInput === "") ? "untitled.ddtxt" : alertInput; // If no input is provided, then create a filename.
	
	sourceFileName = (newFileName.substring(newFileName.length - 6, newFileName.length) === ".ddtxt") ? newFileName : newFileName + ".ddtxt"; // Set the new file's name to the input, adding the correct file extension if not present.
	console.log(alertInput + " | " + newFileName + " | " + sourceFileName);
	sourceFileTime = Date.now(); // Set the new file's lastModified time to the current time.
	
	parseDDTXT(text = "<!DOCTYPE DDTXT>"); // Put only the DOCTYPE statement into the parser, but also trigger a file "loading," resetting the webpage.
	
	// Open the editor.
	editorState = false;
	refreshEditorVisibility();
	// Update the external document features:
	updateExternalText();
	// Make the document statistics UI visible
	document.getElementById("ui").style.visibility = "visible";
	// Update the UI initially
	updateScrollProgress();
};


// HTML elements' code:


// Load the contents of the file and convert it to HTML DDTXT
var loadFileInput = function () {
	// Load the file
	const file = inputReference.files [0]; // Grab the first file (only one at once)
	
	// If there is a file, then read it:
	if (file) {
		// Reset the DDTXT before starting
		clearDDTXT();
		
		// Save this filename for use by the editor:
		sourceFileName = inputReference.files [0].name;
		// Save the file's last modified time to the DDTXT object:
		sourceFileTime = inputReference.files [0].lastModified;
		
		const readFile = inputReference.files [0].text();
		
		stringifiedResult = readFile.then(
			function (result) {
				parseDDTXT(text = result);
				// After parsing (this clears DDTXT), save the filename (not a file path)
				// Update the external document features:
				updateExternalText();
				// Update the document statistics:
				// Make the document statistics UI visible
				document.getElementById("ui").style.visibility = "visible";
				// Update the UI initially
				updateScrollProgress();
				return result; // Pass the raw DDTXT upward
			}
		);
	}
};

// Load a new file's contents
var updateFileInput = function () {
	// Load and parse the file, assigning the data to the DDTXT object:
	loadFileInput(); // (By doing this, override file details in the DDTXT object.)
};

// Print (convert the webpage to a PDF) the DDTXT

var printDDTXT = function () {
	// Get footer reference
	const footer = document.getElementById("footer");
	
	editorState = true;
	refreshEditorVisibility();
	
	// Hide the footer
	footer.visibility = "hidden";
	
	print(); // This seems to trigger the browser's webpage printing.
	
	// Show the footer again
	footer.visibility = "visible";
};

// Setup document progress statistic:
const documentStats = document.getElementById("ui-stats");
const UIToggle = document.getElementById("ui-toggle");

// Whether or not the document statistics are visible.
var statsAreVisible = false;

// Update the percentage:
var updateScrollProgress = function () {
	var progressPercentage = ((document.documentElement.scrollTop - 1) / (document.documentElement.scrollHeight - document.defaultView.innerHeight) * 100).toFixed(1);
	
	// Disallow negative percentages:
	if (progressPercentage [0] === "-") { // The number is a string, so if it's negative, the first text character will be a hyphen
		progressPercentage = "0.0";
	}
	
	// Prefer specified webtitle but default to full document name.
	const nameToShow = (DDTXT.global.webtitle) ? DDTXT.global.webtitle : DDTXT.global.name;
	documentStats.innerHTML = "<em id=\"ui-name\">" + nameToShow + "</em> by " + DDTXT.global.author + " (" + progressPercentage + "% finished)";
};

var updateToggleButton = function () {
	UIToggle.innerHTML = (statsAreVisible) ? "Show stats." : "Hide stats.";
};

// Setup statistics toggle button:
var toggleStats = function () {
	statsAreVisible = !statsAreVisible; // Toggle the boolean
	if (statsAreVisible) {
		document.getElementById("ui").style.visibility = "hidden";
		// Make sure the toggle button is always visible:
		document.getElementById("ui-toggle").style.visibility = "visible";
		document.getElementById("ui-toggle").style.backgroundColor = DDTXT.style.backgroundColor;
	}
	else {
		document.getElementById("ui").style.visibility = "visible";
	}
	updateToggleButton(); // This function updates the text of the toggle button.
}

// Append the code to the HTML element:
document.getElementById("ui-toggle").onclick = toggleStats;

// Append the code object to the DDTXT element
document.onscroll = updateScrollProgress;

// Attach the update function to the input element
inputReference.addEventListener("change", updateFileInput);

// Editor functions

// Jump to the bottom of the editor and document
var jumpToEditorBottom = function () {
	const editorElement = document.getElementById("editor-content");
	const editorElementLength = editorElement.scrollHeight - (document.getElementById("footer").scrollHeight * 2);
	document.defaultView.scroll(0, editorElementLength); // x: 0, y: editorElementLength
	editorElement.scroll(0, editorElementLength)
};

document.getElementById("editor-bottom").onclick = jumpToEditorBottom;

// Jump to the top of the editor and document
var jumpToEditorTop = function () {
	// .scroll(0, 0) resets the scroll of the given element.
	document.defaultView.scroll(0, 0);
	document.getElementById("editor-content").scroll(0, 0);
};

document.getElementById("editor-top").onclick = jumpToEditorTop;

// Refresh the contents of the editor to the reader (push changes forward to the left side of the screen)
var refreshEditorToDDTXT = function () {
	const editorContent = document.getElementById("editor-content").value;
	const newDDTXT = editorContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
	stringifiedDDTXT = newDDTXT;
};

var refreshEditorToReader = function () {
	refreshEditorToDDTXT();
	parseDDTXT(text = stringifiedDDTXT);
	updateExternalText();
};

document.getElementById("editor-refresh").onclick = refreshEditorToReader;

// Export the contents of the editor textbox to a .ddtxt file
var exportToDDTXT = function () {
	refreshEditorToDDTXT(); // Make sure stringifiedDDTXT is current.
	// Prepare the file data and exporting path
	const exportFile = new Blob(
		[stringifiedDDTXT], {
			type: "text/ddtxt",
		}
	);
	const exportFileInternalLink = document.createElement("a", "id=tempLink");
	exportFileInternalLink.href = URL.createObjectURL(exportFile);
	exportFileInternalLink.download = String(DDTXT.global.filename);
	exportFileInternalLink.click(); // Perform the functions that would happen if we could click on the link
	// Clear the URL after this function is over
	URL.revokeObjectURL(exportFileInternalLink.href);
}

document.getElementById("editor-save").onclick = exportToDDTXT;

// Allow the editor to be opened and closed
var editorState = true;
var currentlyEditing = false;

// Open and close the editor:
var refreshEditorVisibility = function () {
	editorElement = document.getElementById("editor");
	footer = document.getElementById("footer");
	// Only show when the summary is hidden
	if (editorState) {
		// It's open. Close it.
		editorElement.style.flex = 0;
		editorElement.style.visibility = "hidden";
		editorElement.style.display = "none";
		footer.style.marginLeft = "0%";
		footer.style.width = "100%";
	}
	else {
		// It's closed. Open it.
		editorElement.style.flex = 1;
		editorElement.style.visibility = "visible";
		editorElement.style.display = "initial";
		footer.style.marginLeft = "50%";
		footer.style.width = "50%";
	}
	// Always reset DDTXT's flex weight to 1
	document.getElementById("DDTXT").style.flex = 1;
};

var toggleEditor = function () {
	editorState = !editorState;
	refreshEditorVisibility();
};

// Connect the press of the E key to opening and closing the editor:
var checkForKey = function (key) {
	// If E is pressed, we are not typing in the editor, and there is a DDTXT loaded, then toggle the editor.
	if (key.key === "e" && !currentlyEditing && stringifiedDDTXT !== "") {
		toggleEditor();
	}
};

// Connect the "Close Editor" button to closing the editor:

document.getElementById("editor-close").onclick = toggleEditor;

// Summary box:

var summaryIsOpen = false;
// Hold the editor's state while in summary so that we can bring it back if needed:
var tempEditorState;
const summaryReference = document.getElementById("summary");

// Main summary box:

summaryReference.onclick = function () {
	summaryIsOpen = false;
	summaryReference.style.visibility = "hidden";
	editorState = tempEditorState; // Use the saved state. (See below)
	refreshEditorVisibility();
};

// Summary button:

document.getElementById("ui-summary").onclick = function () {
	summaryIsOpen = true;
	summaryReference.style.visibility = "visible";
	tempEditorState = editorState; // Save the editor's state.
	editorState = true; // Close the editor no matter what.
	refreshEditorVisibility();
};

// The following function is currently broken:
/*
var adjustEditorWidth = function () {
	const editorWidth = 2 * (document.getElementById("editor-content").getBoundingClientRect().width) / document.defaultView.innerWidth;
	console.log(editorWidth);
	const DDTXTWidth = (2 - editorWidth);
	document.getElementById("DDTXT").style.flex = DDTXTWidth;
	document.getElementById("editor").style.flex = editorWidth;
};*/

document.documentElement.addEventListener("keydown", (key) => {checkForKey(key)}); // Pass the key event down to the above function

document.getElementById("editor-content").addEventListener("keydown", () => {currentlyEditing = true});
document.getElementById("editor-content").addEventListener("keyup", () => {currentlyEditing = false});
//document.getElementById("editor-content").onclick = adjustEditorWidth; // Currently broken

// Debugging information for users:
console.log("To see more about a character,\nuse the function tellMeAbout(<code>),\nwhere <code> is the character's code.");

// I'll use () => {} function shorthand here:
var tellMeAbout = (code) => { console.log(DDTXT.cast.getCharacterByCode(code).toString()); };

</script>

</html>
